// This file is generated by abnf - DO NOT EDIT.

package rfc3261

import (
	"github.com/ghettovoice/abnf"
	"github.com/ghettovoice/abnf/pkg/abnf_core"
)

var ackm abnf.Operator

// ACKm rule: ACKm = %x41.43.4B
func ACKm(s []byte, ns abnf.Nodes) abnf.Nodes {
	if ackm == nil {
		ackm = abnf.Literal("ACKm", []byte{65, 67, 75})
	}
	return ackm(s, ns)
}

var absPath abnf.Operator

// AbsPath rule: abs-path = "/" path-segments
func AbsPath(s []byte, ns abnf.Nodes) abnf.Nodes {
	if absPath == nil {
		absPath = abnf.Concat(
			"abs-path",
			abnf.Literal("\"/\"", []byte{47}),
			PathSegments,
		)
	}
	return absPath(s, ns)
}

var absoluteuri abnf.Operator

// AbsoluteURI rule: absoluteURI = scheme ":" ( hier-part / opaque-part )
func AbsoluteURI(s []byte, ns abnf.Nodes) abnf.Nodes {
	if absoluteuri == nil {
		absoluteuri = abnf.Concat(
			"absoluteURI",
			Scheme,
			abnf.Literal("\":\"", []byte{58}),
			abnf.Alt(
				"hier-part / opaque-part",
				HierPart,
				OpaquePart,
			),
		)
	}
	return absoluteuri(s, ns)
}

var accept abnf.Operator

// Accept rule: Accept = "Accept" HCOLON [ accept-range *(COMMA accept-range) ]
func Accept(s []byte, ns abnf.Nodes) abnf.Nodes {
	if accept == nil {
		accept = abnf.Concat(
			"Accept",
			abnf.Literal("\"Accept\"", []byte{65, 99, 99, 101, 112, 116}),
			HCOLON,
			abnf.Optional("[ accept-range *(COMMA accept-range) ]", abnf.Concat(
				"accept-range *(COMMA accept-range)",
				AcceptRange,
				abnf.Repeat0Inf("*(COMMA accept-range)", abnf.Concat(
					"COMMA accept-range",
					COMMA,
					AcceptRange,
				)),
			)),
		)
	}
	return accept(s, ns)
}

var acceptEncoding abnf.Operator

// AcceptEncoding rule: Accept-Encoding = "Accept-Encoding" HCOLON [ encoding *(COMMA encoding) ]
func AcceptEncoding(s []byte, ns abnf.Nodes) abnf.Nodes {
	if acceptEncoding == nil {
		acceptEncoding = abnf.Concat(
			"Accept-Encoding",
			abnf.Literal("\"Accept-Encoding\"", []byte{65, 99, 99, 101, 112, 116, 45, 69, 110, 99, 111, 100, 105, 110, 103}),
			HCOLON,
			abnf.Optional("[ encoding *(COMMA encoding) ]", abnf.Concat(
				"encoding *(COMMA encoding)",
				Encoding,
				abnf.Repeat0Inf("*(COMMA encoding)", abnf.Concat(
					"COMMA encoding",
					COMMA,
					Encoding,
				)),
			)),
		)
	}
	return acceptEncoding(s, ns)
}

var acceptLanguage abnf.Operator

// AcceptLanguage rule: Accept-Language = "Accept-Language" HCOLON [ language *(COMMA language) ]
func AcceptLanguage(s []byte, ns abnf.Nodes) abnf.Nodes {
	if acceptLanguage == nil {
		acceptLanguage = abnf.Concat(
			"Accept-Language",
			abnf.Literal("\"Accept-Language\"", []byte{65, 99, 99, 101, 112, 116, 45, 76, 97, 110, 103, 117, 97, 103, 101}),
			HCOLON,
			abnf.Optional("[ language *(COMMA language) ]", abnf.Concat(
				"language *(COMMA language)",
				Language,
				abnf.Repeat0Inf("*(COMMA language)", abnf.Concat(
					"COMMA language",
					COMMA,
					Language,
				)),
			)),
		)
	}
	return acceptLanguage(s, ns)
}

var acceptParam abnf.Operator

// AcceptParam rule: accept-param = ("q" EQUAL qvalue) / generic-param
func AcceptParam(s []byte, ns abnf.Nodes) abnf.Nodes {
	if acceptParam == nil {
		acceptParam = abnf.Alt(
			"accept-param",
			abnf.Concat(
				"\"q\" EQUAL qvalue",
				abnf.Literal("\"q\"", []byte{113}),
				EQUAL,
				Qvalue,
			),
			GenericParam,
		)
	}
	return acceptParam(s, ns)
}

var acceptRange abnf.Operator

// AcceptRange rule: accept-range = media-range *(SEMI accept-param)
func AcceptRange(s []byte, ns abnf.Nodes) abnf.Nodes {
	if acceptRange == nil {
		acceptRange = abnf.Concat(
			"accept-range",
			MediaRange,
			abnf.Repeat0Inf("*(SEMI accept-param)", abnf.Concat(
				"SEMI accept-param",
				SEMI,
				AcceptParam,
			)),
		)
	}
	return acceptRange(s, ns)
}

var addrSpec abnf.Operator

// AddrSpec rule: addr-spec = SIP-URI / SIPS-URI / absoluteURI
func AddrSpec(s []byte, ns abnf.Nodes) abnf.Nodes {
	if addrSpec == nil {
		addrSpec = abnf.Alt(
			"addr-spec",
			SIPURI,
			SIPSURI,
			AbsoluteURI,
		)
	}
	return addrSpec(s, ns)
}

var ainfo abnf.Operator

// Ainfo rule: ainfo = nextnonce / message-qop / response-auth / cnonce / nonce-count
func Ainfo(s []byte, ns abnf.Nodes) abnf.Nodes {
	if ainfo == nil {
		ainfo = abnf.Alt(
			"ainfo",
			Nextnonce,
			MessageQop,
			ResponseAuth,
			Cnonce,
			NonceCount,
		)
	}
	return ainfo(s, ns)
}

var alertInfo abnf.Operator

// AlertInfo rule: Alert-Info = "Alert-Info" HCOLON alert-param *(COMMA alert-param)
func AlertInfo(s []byte, ns abnf.Nodes) abnf.Nodes {
	if alertInfo == nil {
		alertInfo = abnf.Concat(
			"Alert-Info",
			abnf.Literal("\"Alert-Info\"", []byte{65, 108, 101, 114, 116, 45, 73, 110, 102, 111}),
			HCOLON,
			AlertParam,
			abnf.Repeat0Inf("*(COMMA alert-param)", abnf.Concat(
				"COMMA alert-param",
				COMMA,
				AlertParam,
			)),
		)
	}
	return alertInfo(s, ns)
}

var alertParam abnf.Operator

// AlertParam rule: alert-param = LAQUOT absoluteURI RAQUOT *( SEMI generic-param )
func AlertParam(s []byte, ns abnf.Nodes) abnf.Nodes {
	if alertParam == nil {
		alertParam = abnf.Concat(
			"alert-param",
			LAQUOT,
			AbsoluteURI,
			RAQUOT,
			abnf.Repeat0Inf("*( SEMI generic-param )", abnf.Concat(
				"SEMI generic-param",
				SEMI,
				GenericParam,
			)),
		)
	}
	return alertParam(s, ns)
}

var algorithm abnf.Operator

// Algorithm rule: algorithm = "algorithm" EQUAL ( "MD5" / "MD5-sess" / token )
func Algorithm(s []byte, ns abnf.Nodes) abnf.Nodes {
	if algorithm == nil {
		algorithm = abnf.Concat(
			"algorithm",
			abnf.Literal("\"algorithm\"", []byte{97, 108, 103, 111, 114, 105, 116, 104, 109}),
			EQUAL,
			abnf.Alt(
				"\"MD5\" / \"MD5-sess\" / token",
				abnf.Literal("\"MD5\"", []byte{77, 68, 53}),
				abnf.Literal("\"MD5-sess\"", []byte{77, 68, 53, 45, 115, 101, 115, 115}),
				Token,
			),
		)
	}
	return algorithm(s, ns)
}

var allow abnf.Operator

// Allow rule: Allow = "Allow" HCOLON [Method *(COMMA Method)]
func Allow(s []byte, ns abnf.Nodes) abnf.Nodes {
	if allow == nil {
		allow = abnf.Concat(
			"Allow",
			abnf.Literal("\"Allow\"", []byte{65, 108, 108, 111, 119}),
			HCOLON,
			abnf.Optional("[Method *(COMMA Method)]", abnf.Concat(
				"Method *(COMMA Method)",
				Method,
				abnf.Repeat0Inf("*(COMMA Method)", abnf.Concat(
					"COMMA Method",
					COMMA,
					Method,
				)),
			)),
		)
	}
	return allow(s, ns)
}

var alphanum abnf.Operator

// Alphanum rule: alphanum = ALPHA / DIGIT
func Alphanum(s []byte, ns abnf.Nodes) abnf.Nodes {
	if alphanum == nil {
		alphanum = abnf.Alt(
			"alphanum",
			abnf_core.ALPHA,
			abnf_core.DIGIT,
		)
	}
	return alphanum(s, ns)
}

var authParam abnf.Operator

// AuthParam rule: auth-param = auth-param-name EQUAL ( token / quoted-string )
func AuthParam(s []byte, ns abnf.Nodes) abnf.Nodes {
	if authParam == nil {
		authParam = abnf.Concat(
			"auth-param",
			AuthParamName,
			EQUAL,
			abnf.Alt(
				"token / quoted-string",
				Token,
				QuotedString,
			),
		)
	}
	return authParam(s, ns)
}

var authParamName abnf.Operator

// AuthParamName rule: auth-param-name = token
func AuthParamName(s []byte, ns abnf.Nodes) abnf.Nodes {
	if authParamName == nil {
		authParamName = Token
	}
	return authParamName(s, ns)
}

var authScheme abnf.Operator

// AuthScheme rule: auth-scheme = token
func AuthScheme(s []byte, ns abnf.Nodes) abnf.Nodes {
	if authScheme == nil {
		authScheme = Token
	}
	return authScheme(s, ns)
}

var authenticationInfo abnf.Operator

// AuthenticationInfo rule: Authentication-Info = "Authentication-Info" HCOLON ainfo *(COMMA ainfo)
func AuthenticationInfo(s []byte, ns abnf.Nodes) abnf.Nodes {
	if authenticationInfo == nil {
		authenticationInfo = abnf.Concat(
			"Authentication-Info",
			abnf.Literal("\"Authentication-Info\"", []byte{65, 117, 116, 104, 101, 110, 116, 105, 99, 97, 116, 105, 111, 110, 45, 73, 110, 102, 111}),
			HCOLON,
			Ainfo,
			abnf.Repeat0Inf("*(COMMA ainfo)", abnf.Concat(
				"COMMA ainfo",
				COMMA,
				Ainfo,
			)),
		)
	}
	return authenticationInfo(s, ns)
}

var authority abnf.Operator

// Authority rule: authority = srvr / reg-name
func Authority(s []byte, ns abnf.Nodes) abnf.Nodes {
	if authority == nil {
		authority = abnf.Alt(
			"authority",
			Srvr,
			RegName,
		)
	}
	return authority(s, ns)
}

var authorization abnf.Operator

// Authorization rule: Authorization = "Authorization" HCOLON credentials
func Authorization(s []byte, ns abnf.Nodes) abnf.Nodes {
	if authorization == nil {
		authorization = abnf.Concat(
			"Authorization",
			abnf.Literal("\"Authorization\"", []byte{65, 117, 116, 104, 111, 114, 105, 122, 97, 116, 105, 111, 110}),
			HCOLON,
			Credentials,
		)
	}
	return authorization(s, ns)
}

var authzServer abnf.Operator

// AuthzServer rule: authz-server = absoluteURI
func AuthzServer(s []byte, ns abnf.Nodes) abnf.Nodes {
	if authzServer == nil {
		authzServer = AbsoluteURI
	}
	return authzServer(s, ns)
}

var authzServerParam abnf.Operator

// AuthzServerParam rule: authz-server-param = "authz_server" EQUAL DQUOTE authz-server DQUOTE
func AuthzServerParam(s []byte, ns abnf.Nodes) abnf.Nodes {
	if authzServerParam == nil {
		authzServerParam = abnf.Concat(
			"authz-server-param",
			abnf.Literal("\"authz_server\"", []byte{97, 117, 116, 104, 122, 95, 115, 101, 114, 118, 101, 114}),
			EQUAL,
			abnf_core.DQUOTE,
			AuthzServer,
			abnf_core.DQUOTE,
		)
	}
	return authzServerParam(s, ns)
}

var byem abnf.Operator

// BYEm rule: BYEm = %x42.59.45
func BYEm(s []byte, ns abnf.Nodes) abnf.Nodes {
	if byem == nil {
		byem = abnf.Literal("BYEm", []byte{66, 89, 69})
	}
	return byem(s, ns)
}

var bearerCln abnf.Operator

// BearerCln rule: bearer-cln = realm / scope-param / authz-server-param / error-param / auth-param
func BearerCln(s []byte, ns abnf.Nodes) abnf.Nodes {
	if bearerCln == nil {
		bearerCln = abnf.Alt(
			"bearer-cln",
			Realm,
			ScopeParam,
			AuthzServerParam,
			ErrorParam,
			AuthParam,
		)
	}
	return bearerCln(s, ns)
}

var bearerResponse abnf.Operator

// BearerResponse rule: bearer-response = 1*VSCHAR
func BearerResponse(s []byte, ns abnf.Nodes) abnf.Nodes {
	if bearerResponse == nil {
		bearerResponse = abnf.Repeat1Inf("bearer-response", VSCHAR)
	}
	return bearerResponse(s, ns)
}

var cancelm abnf.Operator

// CANCELm rule: CANCELm = %x43.41.4E.43.45.4C
func CANCELm(s []byte, ns abnf.Nodes) abnf.Nodes {
	if cancelm == nil {
		cancelm = abnf.Literal("CANCELm", []byte{67, 65, 78, 67, 69, 76})
	}
	return cancelm(s, ns)
}

var colon abnf.Operator

// COLON rule: COLON = SWS ":" SWS
func COLON(s []byte, ns abnf.Nodes) abnf.Nodes {
	if colon == nil {
		colon = abnf.Concat(
			"COLON",
			SWS,
			abnf.Literal("\":\"", []byte{58}),
			SWS,
		)
	}
	return colon(s, ns)
}

var comma abnf.Operator

// COMMA rule: COMMA = SWS "," SWS
func COMMA(s []byte, ns abnf.Nodes) abnf.Nodes {
	if comma == nil {
		comma = abnf.Concat(
			"COMMA",
			SWS,
			abnf.Literal("\",\"", []byte{44}),
			SWS,
		)
	}
	return comma(s, ns)
}

var cPExpires abnf.Operator

// CPExpires rule: c-p-expires = "expires" EQUAL delta-seconds
func CPExpires(s []byte, ns abnf.Nodes) abnf.Nodes {
	if cPExpires == nil {
		cPExpires = abnf.Concat(
			"c-p-expires",
			abnf.Literal("\"expires\"", []byte{101, 120, 112, 105, 114, 101, 115}),
			EQUAL,
			DeltaSeconds,
		)
	}
	return cPExpires(s, ns)
}

var cPQ abnf.Operator

// CPQ rule: c-p-q = "q" EQUAL qvalue
func CPQ(s []byte, ns abnf.Nodes) abnf.Nodes {
	if cPQ == nil {
		cPQ = abnf.Concat(
			"c-p-q",
			abnf.Literal("\"q\"", []byte{113}),
			EQUAL,
			Qvalue,
		)
	}
	return cPQ(s, ns)
}

var cseq abnf.Operator

// CSeq rule: CSeq = "CSeq" HCOLON 1*DIGIT LWS Method
func CSeq(s []byte, ns abnf.Nodes) abnf.Nodes {
	if cseq == nil {
		cseq = abnf.Concat(
			"CSeq",
			abnf.Literal("\"CSeq\"", []byte{67, 83, 101, 113}),
			HCOLON,
			abnf.Repeat1Inf("1*DIGIT", abnf_core.DIGIT),
			LWS,
			Method,
		)
	}
	return cseq(s, ns)
}

var callID abnf.Operator

// CallID rule: Call-ID = ( "Call-ID" / "i" ) HCOLON callid
func CallID(s []byte, ns abnf.Nodes) abnf.Nodes {
	if callID == nil {
		callID = abnf.Concat(
			"Call-ID",
			abnf.Alt(
				"\"Call-ID\" / \"i\"",
				abnf.Literal("\"Call-ID\"", []byte{67, 97, 108, 108, 45, 73, 68}),
				abnf.Literal("\"i\"", []byte{105}),
			),
			HCOLON,
			Callid,
		)
	}
	return callID(s, ns)
}

var callInfo abnf.Operator

// CallInfo rule: Call-Info = "Call-Info" HCOLON info *(COMMA info)
func CallInfo(s []byte, ns abnf.Nodes) abnf.Nodes {
	if callInfo == nil {
		callInfo = abnf.Concat(
			"Call-Info",
			abnf.Literal("\"Call-Info\"", []byte{67, 97, 108, 108, 45, 73, 110, 102, 111}),
			HCOLON,
			Info,
			abnf.Repeat0Inf("*(COMMA info)", abnf.Concat(
				"COMMA info",
				COMMA,
				Info,
			)),
		)
	}
	return callInfo(s, ns)
}

var callid abnf.Operator

// Callid rule: callid = word [ "@" word ]
func Callid(s []byte, ns abnf.Nodes) abnf.Nodes {
	if callid == nil {
		callid = abnf.Concat(
			"callid",
			Word,
			abnf.Optional("[ \"@\" word ]", abnf.Concat(
				"\"@\" word",
				abnf.Literal("\"@\"", []byte{64}),
				Word,
			)),
		)
	}
	return callid(s, ns)
}

var challenge abnf.Operator

// Challenge rule: challenge = ("Digest" LWS digest-cln *(COMMA digest-cln)) / ("Bearer" LWS bearer-cln *(COMMA bearer-cln)) ; RFC 8898 patch / other-challenge
func Challenge(s []byte, ns abnf.Nodes) abnf.Nodes {
	if challenge == nil {
		challenge = abnf.Alt(
			"challenge",
			abnf.Concat(
				"\"Digest\" LWS digest-cln *(COMMA digest-cln)",
				abnf.Literal("\"Digest\"", []byte{68, 105, 103, 101, 115, 116}),
				LWS,
				DigestCln,
				abnf.Repeat0Inf("*(COMMA digest-cln)", abnf.Concat(
					"COMMA digest-cln",
					COMMA,
					DigestCln,
				)),
			),
			abnf.Concat(
				"\"Bearer\" LWS bearer-cln *(COMMA bearer-cln)",
				abnf.Literal("\"Bearer\"", []byte{66, 101, 97, 114, 101, 114}),
				LWS,
				BearerCln,
				abnf.Repeat0Inf("*(COMMA bearer-cln)", abnf.Concat(
					"COMMA bearer-cln",
					COMMA,
					BearerCln,
				)),
			),
			OtherChallenge,
		)
	}
	return challenge(s, ns)
}

var clientError abnf.Operator

// ClientError rule: Client-Error = "400" ; Bad Request / "401" ; Unauthorized / "402" ; Payment Required / "403" ; Forbidden / "404" ; Not Found / "405" ; Method Not Allowed / "406" ; Not Acceptable / "407" ; Proxy Authentication Required / "408" ; Request Timeout / "410" ; Gone / "413" ; Request Entity Too Large / "414" ; Request-URI Too Large / "415" ; Unsupported Media Type / "416" ; Unsupported URI Scheme / "420" ; Bad Extension / "421" ; Extension Required / "423" ; Interval Too Brief / "480" ; Temporarily not available / "481" ; Call Leg/Transaction Does Not Exist / "482" ; Loop Detected / "483" ; Too Many Hops / "484" ; Address Incomplete / "485" ; Ambiguous / "486" ; Busy Here / "487" ; Request Terminated / "488" ; Not Acceptable Here / "491" ; Request Pending / "493"
func ClientError(s []byte, ns abnf.Nodes) abnf.Nodes {
	if clientError == nil {
		clientError = abnf.Alt(
			"Client-Error",
			abnf.Literal("\"400\"", []byte{52, 48, 48}),
			abnf.Literal("\"401\"", []byte{52, 48, 49}),
			abnf.Literal("\"402\"", []byte{52, 48, 50}),
			abnf.Literal("\"403\"", []byte{52, 48, 51}),
			abnf.Literal("\"404\"", []byte{52, 48, 52}),
			abnf.Literal("\"405\"", []byte{52, 48, 53}),
			abnf.Literal("\"406\"", []byte{52, 48, 54}),
			abnf.Literal("\"407\"", []byte{52, 48, 55}),
			abnf.Literal("\"408\"", []byte{52, 48, 56}),
			abnf.Literal("\"410\"", []byte{52, 49, 48}),
			abnf.Literal("\"413\"", []byte{52, 49, 51}),
			abnf.Literal("\"414\"", []byte{52, 49, 52}),
			abnf.Literal("\"415\"", []byte{52, 49, 53}),
			abnf.Literal("\"416\"", []byte{52, 49, 54}),
			abnf.Literal("\"420\"", []byte{52, 50, 48}),
			abnf.Literal("\"421\"", []byte{52, 50, 49}),
			abnf.Literal("\"423\"", []byte{52, 50, 51}),
			abnf.Literal("\"480\"", []byte{52, 56, 48}),
			abnf.Literal("\"481\"", []byte{52, 56, 49}),
			abnf.Literal("\"482\"", []byte{52, 56, 50}),
			abnf.Literal("\"483\"", []byte{52, 56, 51}),
			abnf.Literal("\"484\"", []byte{52, 56, 52}),
			abnf.Literal("\"485\"", []byte{52, 56, 53}),
			abnf.Literal("\"486\"", []byte{52, 56, 54}),
			abnf.Literal("\"487\"", []byte{52, 56, 55}),
			abnf.Literal("\"488\"", []byte{52, 56, 56}),
			abnf.Literal("\"491\"", []byte{52, 57, 49}),
			abnf.Literal("\"493\"", []byte{52, 57, 51}),
		)
	}
	return clientError(s, ns)
}

var cnonce abnf.Operator

// Cnonce rule: cnonce = "cnonce" EQUAL cnonce-value
func Cnonce(s []byte, ns abnf.Nodes) abnf.Nodes {
	if cnonce == nil {
		cnonce = abnf.Concat(
			"cnonce",
			abnf.Literal("\"cnonce\"", []byte{99, 110, 111, 110, 99, 101}),
			EQUAL,
			CnonceValue,
		)
	}
	return cnonce(s, ns)
}

var cnonceValue abnf.Operator

// CnonceValue rule: cnonce-value = nonce-value
func CnonceValue(s []byte, ns abnf.Nodes) abnf.Nodes {
	if cnonceValue == nil {
		cnonceValue = NonceValue
	}
	return cnonceValue(s, ns)
}

var codings abnf.Operator

// Codings rule: codings = content-coding / "*"
func Codings(s []byte, ns abnf.Nodes) abnf.Nodes {
	if codings == nil {
		codings = abnf.Alt(
			"codings",
			ContentCoding,
			abnf.Literal("\"*\"", []byte{42}),
		)
	}
	return codings(s, ns)
}

var comment abnf.Operator

// Comment rule: comment = LPAREN *(ctext / quoted-pair) RPAREN
func Comment(s []byte, ns abnf.Nodes) abnf.Nodes {
	if comment == nil {
		comment = abnf.Concat(
			"comment",
			LPAREN,
			abnf.Repeat0Inf("*(ctext / quoted-pair)", abnf.Alt(
				"ctext / quoted-pair",
				Ctext,
				QuotedPair,
			)),
			RPAREN,
		)
	}
	return comment(s, ns)
}

var compositeType abnf.Operator

// CompositeType rule: composite-type = "message" / "multipart" / extension-token
func CompositeType(s []byte, ns abnf.Nodes) abnf.Nodes {
	if compositeType == nil {
		compositeType = abnf.Alt(
			"composite-type",
			abnf.Literal("\"message\"", []byte{109, 101, 115, 115, 97, 103, 101}),
			abnf.Literal("\"multipart\"", []byte{109, 117, 108, 116, 105, 112, 97, 114, 116}),
			ExtensionToken,
		)
	}
	return compositeType(s, ns)
}

var contact abnf.Operator

// Contact rule: Contact = ("Contact" / "m" ) HCOLON ( STAR / (contact-param *(COMMA contact-param)))
func Contact(s []byte, ns abnf.Nodes) abnf.Nodes {
	if contact == nil {
		contact = abnf.Concat(
			"Contact",
			abnf.Alt(
				"\"Contact\" / \"m\"",
				abnf.Literal("\"Contact\"", []byte{67, 111, 110, 116, 97, 99, 116}),
				abnf.Literal("\"m\"", []byte{109}),
			),
			HCOLON,
			abnf.Alt(
				"STAR / (contact-param *(COMMA contact-param))",
				STAR,
				abnf.Concat(
					"contact-param *(COMMA contact-param)",
					ContactParam,
					abnf.Repeat0Inf("*(COMMA contact-param)", abnf.Concat(
						"COMMA contact-param",
						COMMA,
						ContactParam,
					)),
				),
			),
		)
	}
	return contact(s, ns)
}

var contactExtension abnf.Operator

// ContactExtension rule: contact-extension = generic-param
func ContactExtension(s []byte, ns abnf.Nodes) abnf.Nodes {
	if contactExtension == nil {
		contactExtension = GenericParam
	}
	return contactExtension(s, ns)
}

var contactParam abnf.Operator

// ContactParam rule: contact-param = (name-addr / addr-spec) *(SEMI contact-params)
func ContactParam(s []byte, ns abnf.Nodes) abnf.Nodes {
	if contactParam == nil {
		contactParam = abnf.Concat(
			"contact-param",
			abnf.Alt(
				"name-addr / addr-spec",
				NameAddr,
				AddrSpec,
			),
			abnf.Repeat0Inf("*(SEMI contact-params)", abnf.Concat(
				"SEMI contact-params",
				SEMI,
				ContactParams,
			)),
		)
	}
	return contactParam(s, ns)
}

var contactParams abnf.Operator

// ContactParams rule: contact-params = c-p-q / c-p-expires / contact-extension
func ContactParams(s []byte, ns abnf.Nodes) abnf.Nodes {
	if contactParams == nil {
		contactParams = abnf.Alt(
			"contact-params",
			CPQ,
			CPExpires,
			ContactExtension,
		)
	}
	return contactParams(s, ns)
}

var contentCoding abnf.Operator

// ContentCoding rule: content-coding = token
func ContentCoding(s []byte, ns abnf.Nodes) abnf.Nodes {
	if contentCoding == nil {
		contentCoding = Token
	}
	return contentCoding(s, ns)
}

var contentDisposition abnf.Operator

// ContentDisposition rule: Content-Disposition = "Content-Disposition" HCOLON disp-type *( SEMI disp-param )
func ContentDisposition(s []byte, ns abnf.Nodes) abnf.Nodes {
	if contentDisposition == nil {
		contentDisposition = abnf.Concat(
			"Content-Disposition",
			abnf.Literal("\"Content-Disposition\"", []byte{67, 111, 110, 116, 101, 110, 116, 45, 68, 105, 115, 112, 111, 115, 105, 116, 105, 111, 110}),
			HCOLON,
			DispType,
			abnf.Repeat0Inf("*( SEMI disp-param )", abnf.Concat(
				"SEMI disp-param",
				SEMI,
				DispParam,
			)),
		)
	}
	return contentDisposition(s, ns)
}

var contentEncoding abnf.Operator

// ContentEncoding rule: Content-Encoding = ( "Content-Encoding" / "e" ) HCOLON content-coding *(COMMA content-coding)
func ContentEncoding(s []byte, ns abnf.Nodes) abnf.Nodes {
	if contentEncoding == nil {
		contentEncoding = abnf.Concat(
			"Content-Encoding",
			abnf.Alt(
				"\"Content-Encoding\" / \"e\"",
				abnf.Literal("\"Content-Encoding\"", []byte{67, 111, 110, 116, 101, 110, 116, 45, 69, 110, 99, 111, 100, 105, 110, 103}),
				abnf.Literal("\"e\"", []byte{101}),
			),
			HCOLON,
			ContentCoding,
			abnf.Repeat0Inf("*(COMMA content-coding)", abnf.Concat(
				"COMMA content-coding",
				COMMA,
				ContentCoding,
			)),
		)
	}
	return contentEncoding(s, ns)
}

var contentLanguage abnf.Operator

// ContentLanguage rule: Content-Language = "Content-Language" HCOLON language-tag *(COMMA language-tag)
func ContentLanguage(s []byte, ns abnf.Nodes) abnf.Nodes {
	if contentLanguage == nil {
		contentLanguage = abnf.Concat(
			"Content-Language",
			abnf.Literal("\"Content-Language\"", []byte{67, 111, 110, 116, 101, 110, 116, 45, 76, 97, 110, 103, 117, 97, 103, 101}),
			HCOLON,
			LanguageTag,
			abnf.Repeat0Inf("*(COMMA language-tag)", abnf.Concat(
				"COMMA language-tag",
				COMMA,
				LanguageTag,
			)),
		)
	}
	return contentLanguage(s, ns)
}

var contentLength abnf.Operator

// ContentLength rule: Content-Length = ( "Content-Length" / "l" ) HCOLON 1*DIGIT
func ContentLength(s []byte, ns abnf.Nodes) abnf.Nodes {
	if contentLength == nil {
		contentLength = abnf.Concat(
			"Content-Length",
			abnf.Alt(
				"\"Content-Length\" / \"l\"",
				abnf.Literal("\"Content-Length\"", []byte{67, 111, 110, 116, 101, 110, 116, 45, 76, 101, 110, 103, 116, 104}),
				abnf.Literal("\"l\"", []byte{108}),
			),
			HCOLON,
			abnf.Repeat1Inf("1*DIGIT", abnf_core.DIGIT),
		)
	}
	return contentLength(s, ns)
}

var contentType abnf.Operator

// ContentType rule: Content-Type = ( "Content-Type" / "c" ) HCOLON media-type
func ContentType(s []byte, ns abnf.Nodes) abnf.Nodes {
	if contentType == nil {
		contentType = abnf.Concat(
			"Content-Type",
			abnf.Alt(
				"\"Content-Type\" / \"c\"",
				abnf.Literal("\"Content-Type\"", []byte{67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101}),
				abnf.Literal("\"c\"", []byte{99}),
			),
			HCOLON,
			MediaType,
		)
	}
	return contentType(s, ns)
}

var credentials abnf.Operator

// Credentials rule: credentials = ("Digest" LWS digest-response) / ("Bearer" LWS bearer-response) ; RFC 8898 patch / other-response
func Credentials(s []byte, ns abnf.Nodes) abnf.Nodes {
	if credentials == nil {
		credentials = abnf.Alt(
			"credentials",
			abnf.Concat(
				"\"Digest\" LWS digest-response",
				abnf.Literal("\"Digest\"", []byte{68, 105, 103, 101, 115, 116}),
				LWS,
				DigestResponse,
			),
			abnf.Concat(
				"\"Bearer\" LWS bearer-response",
				abnf.Literal("\"Bearer\"", []byte{66, 101, 97, 114, 101, 114}),
				LWS,
				BearerResponse,
			),
			OtherResponse,
		)
	}
	return credentials(s, ns)
}

var ctext abnf.Operator

// Ctext rule: ctext = %x21-27 / %x2A-5B / %x5D-7E / UTF8-NONASCII / LWS
func Ctext(s []byte, ns abnf.Nodes) abnf.Nodes {
	if ctext == nil {
		ctext = abnf.Alt(
			"ctext",
			abnf.Range("%x21-27", []byte{33}, []byte{39}),
			abnf.Range("%x2A-5B", []byte{42}, []byte{91}),
			abnf.Range("%x5D-7E", []byte{93}, []byte{126}),
			UTF8NONASCII,
			LWS,
		)
	}
	return ctext(s, ns)
}

var date abnf.Operator

// Date rule: Date = "Date" HCOLON SIP-date
func Date(s []byte, ns abnf.Nodes) abnf.Nodes {
	if date == nil {
		date = abnf.Concat(
			"Date",
			abnf.Literal("\"Date\"", []byte{68, 97, 116, 101}),
			HCOLON,
			SIPDate,
		)
	}
	return date(s, ns)
}

var date1 abnf.Operator

// Date1 rule: date1 = 2DIGIT SP month SP 4DIGIT
func Date1(s []byte, ns abnf.Nodes) abnf.Nodes {
	if date1 == nil {
		date1 = abnf.Concat(
			"date1",
			abnf.RepeatN("2DIGIT", uint(0x2), abnf_core.DIGIT),
			abnf_core.SP,
			Month,
			abnf_core.SP,
			abnf.RepeatN("4DIGIT", uint(0x4), abnf_core.DIGIT),
		)
	}
	return date1(s, ns)
}

var decOctet abnf.Operator

// DecOctet rule: dec-octet = DIGIT ; 0-9 / %x31-39 DIGIT ; 10-99 / "1" 2DIGIT ; 100-199 / "2" %x30-34 DIGIT ; 200-249 / "25" %x30-35
func DecOctet(s []byte, ns abnf.Nodes) abnf.Nodes {
	if decOctet == nil {
		decOctet = abnf.Alt(
			"dec-octet",
			abnf_core.DIGIT,
			abnf.Concat(
				"%x31-39 DIGIT",
				abnf.Range("%x31-39", []byte{49}, []byte{57}),
				abnf_core.DIGIT,
			),
			abnf.Concat(
				"\"1\" 2DIGIT",
				abnf.Literal("\"1\"", []byte{49}),
				abnf.RepeatN("2DIGIT", uint(0x2), abnf_core.DIGIT),
			),
			abnf.Concat(
				"\"2\" %x30-34 DIGIT",
				abnf.Literal("\"2\"", []byte{50}),
				abnf.Range("%x30-34", []byte{48}, []byte{52}),
				abnf_core.DIGIT,
			),
			abnf.Concat(
				"\"25\" %x30-35",
				abnf.Literal("\"25\"", []byte{50, 53}),
				abnf.Range("%x30-35", []byte{48}, []byte{53}),
			),
		)
	}
	return decOctet(s, ns)
}

var delay abnf.Operator

// Delay rule: delay = *(DIGIT) [ "." *(DIGIT) ]
func Delay(s []byte, ns abnf.Nodes) abnf.Nodes {
	if delay == nil {
		delay = abnf.Concat(
			"delay",
			abnf.Repeat0Inf("*(DIGIT)", abnf_core.DIGIT),
			abnf.Optional("[ \".\" *(DIGIT) ]", abnf.Concat(
				"\".\" *(DIGIT)",
				abnf.Literal("\".\"", []byte{46}),
				abnf.Repeat0Inf("*(DIGIT)", abnf_core.DIGIT),
			)),
		)
	}
	return delay(s, ns)
}

var deltaSeconds abnf.Operator

// DeltaSeconds rule: delta-seconds = 1*DIGIT
func DeltaSeconds(s []byte, ns abnf.Nodes) abnf.Nodes {
	if deltaSeconds == nil {
		deltaSeconds = abnf.Repeat1Inf("delta-seconds", abnf_core.DIGIT)
	}
	return deltaSeconds(s, ns)
}

var digResp abnf.Operator

// DigResp rule: dig-resp = username / realm / nonce / digest-uri / dresponse / algorithm / cnonce / opaque / message-qop / nonce-count / auth-param
func DigResp(s []byte, ns abnf.Nodes) abnf.Nodes {
	if digResp == nil {
		digResp = abnf.Alt(
			"dig-resp",
			Username,
			Realm,
			Nonce,
			DigestUri,
			Dresponse,
			Algorithm,
			Cnonce,
			Opaque,
			MessageQop,
			NonceCount,
			AuthParam,
		)
	}
	return digResp(s, ns)
}

var digestCln abnf.Operator

// DigestCln rule: digest-cln = realm / domain / nonce / opaque / stale / algorithm / qop-options / auth-param
func DigestCln(s []byte, ns abnf.Nodes) abnf.Nodes {
	if digestCln == nil {
		digestCln = abnf.Alt(
			"digest-cln",
			Realm,
			Domain,
			Nonce,
			Opaque,
			Stale,
			Algorithm,
			QopOptions,
			AuthParam,
		)
	}
	return digestCln(s, ns)
}

var digestResponse abnf.Operator

// DigestResponse rule: digest-response = dig-resp *(COMMA dig-resp)
func DigestResponse(s []byte, ns abnf.Nodes) abnf.Nodes {
	if digestResponse == nil {
		digestResponse = abnf.Concat(
			"digest-response",
			DigResp,
			abnf.Repeat0Inf("*(COMMA dig-resp)", abnf.Concat(
				"COMMA dig-resp",
				COMMA,
				DigResp,
			)),
		)
	}
	return digestResponse(s, ns)
}

var digestUri abnf.Operator

// DigestUri rule: digest-uri = "uri" EQUAL LDQUOT digest-uri-value RDQUOT
func DigestUri(s []byte, ns abnf.Nodes) abnf.Nodes {
	if digestUri == nil {
		digestUri = abnf.Concat(
			"digest-uri",
			abnf.Literal("\"uri\"", []byte{117, 114, 105}),
			EQUAL,
			LDQUOT,
			DigestUriValue,
			RDQUOT,
		)
	}
	return digestUri(s, ns)
}

var digestUriValue abnf.Operator

// DigestUriValue rule: digest-uri-value = request-uri
func DigestUriValue(s []byte, ns abnf.Nodes) abnf.Nodes {
	if digestUriValue == nil {
		digestUriValue = RequestUri
	}
	return digestUriValue(s, ns)
}

var discreteType abnf.Operator

// DiscreteType rule: discrete-type = "text" / "image" / "audio" / "video" / "application" / extension-token
func DiscreteType(s []byte, ns abnf.Nodes) abnf.Nodes {
	if discreteType == nil {
		discreteType = abnf.Alt(
			"discrete-type",
			abnf.Literal("\"text\"", []byte{116, 101, 120, 116}),
			abnf.Literal("\"image\"", []byte{105, 109, 97, 103, 101}),
			abnf.Literal("\"audio\"", []byte{97, 117, 100, 105, 111}),
			abnf.Literal("\"video\"", []byte{118, 105, 100, 101, 111}),
			abnf.Literal("\"application\"", []byte{97, 112, 112, 108, 105, 99, 97, 116, 105, 111, 110}),
			ExtensionToken,
		)
	}
	return discreteType(s, ns)
}

var dispExtensionToken abnf.Operator

// DispExtensionToken rule: disp-extension-token = token
func DispExtensionToken(s []byte, ns abnf.Nodes) abnf.Nodes {
	if dispExtensionToken == nil {
		dispExtensionToken = Token
	}
	return dispExtensionToken(s, ns)
}

var dispParam abnf.Operator

// DispParam rule: disp-param = handling-param / generic-param
func DispParam(s []byte, ns abnf.Nodes) abnf.Nodes {
	if dispParam == nil {
		dispParam = abnf.Alt(
			"disp-param",
			HandlingParam,
			GenericParam,
		)
	}
	return dispParam(s, ns)
}

var dispType abnf.Operator

// DispType rule: disp-type = "render" / "session" / "icon" / "alert" / disp-extension-token
func DispType(s []byte, ns abnf.Nodes) abnf.Nodes {
	if dispType == nil {
		dispType = abnf.Alt(
			"disp-type",
			abnf.Literal("\"render\"", []byte{114, 101, 110, 100, 101, 114}),
			abnf.Literal("\"session\"", []byte{115, 101, 115, 115, 105, 111, 110}),
			abnf.Literal("\"icon\"", []byte{105, 99, 111, 110}),
			abnf.Literal("\"alert\"", []byte{97, 108, 101, 114, 116}),
			DispExtensionToken,
		)
	}
	return dispType(s, ns)
}

var displayName abnf.Operator

// DisplayName rule: display-name = *(token LWS)/ quoted-string
func DisplayName(s []byte, ns abnf.Nodes) abnf.Nodes {
	if displayName == nil {
		displayName = abnf.Alt(
			"display-name",
			abnf.Repeat0Inf("*(token LWS)", abnf.Concat(
				"token LWS",
				Token,
				LWS,
			)),
			QuotedString,
		)
	}
	return displayName(s, ns)
}

var domain abnf.Operator

// Domain rule: domain = "domain" EQUAL LDQUOT URI *( 1*SP URI ) RDQUOT
func Domain(s []byte, ns abnf.Nodes) abnf.Nodes {
	if domain == nil {
		domain = abnf.Concat(
			"domain",
			abnf.Literal("\"domain\"", []byte{100, 111, 109, 97, 105, 110}),
			EQUAL,
			LDQUOT,
			URI,
			abnf.Repeat0Inf("*( 1*SP URI )", abnf.Concat(
				"1*SP URI",
				abnf.Repeat1Inf("1*SP", abnf_core.SP),
				URI,
			)),
			RDQUOT,
		)
	}
	return domain(s, ns)
}

var domainlabel abnf.Operator

// Domainlabel rule: domainlabel = alphanum / alphanum *( alphanum / "-" ) alphanum
func Domainlabel(s []byte, ns abnf.Nodes) abnf.Nodes {
	if domainlabel == nil {
		domainlabel = abnf.Alt(
			"domainlabel",
			Alphanum,
			abnf.Concat(
				"alphanum *( alphanum / \"-\" ) alphanum",
				Alphanum,
				abnf.Repeat0Inf("*( alphanum / \"-\" )", abnf.Alt(
					"alphanum / \"-\"",
					Alphanum,
					abnf.Literal("\"-\"", []byte{45}),
				)),
				Alphanum,
			),
		)
	}
	return domainlabel(s, ns)
}

var dresponse abnf.Operator

// Dresponse rule: dresponse = "response" EQUAL request-digest
func Dresponse(s []byte, ns abnf.Nodes) abnf.Nodes {
	if dresponse == nil {
		dresponse = abnf.Concat(
			"dresponse",
			abnf.Literal("\"response\"", []byte{114, 101, 115, 112, 111, 110, 115, 101}),
			EQUAL,
			RequestDigest,
		)
	}
	return dresponse(s, ns)
}

var equal abnf.Operator

// EQUAL rule: EQUAL = SWS "=" SWS
func EQUAL(s []byte, ns abnf.Nodes) abnf.Nodes {
	if equal == nil {
		equal = abnf.Concat(
			"EQUAL",
			SWS,
			abnf.Literal("\"=\"", []byte{61}),
			SWS,
		)
	}
	return equal(s, ns)
}

var encoding abnf.Operator

// Encoding rule: encoding = codings *(SEMI accept-param)
func Encoding(s []byte, ns abnf.Nodes) abnf.Nodes {
	if encoding == nil {
		encoding = abnf.Concat(
			"encoding",
			Codings,
			abnf.Repeat0Inf("*(SEMI accept-param)", abnf.Concat(
				"SEMI accept-param",
				SEMI,
				AcceptParam,
			)),
		)
	}
	return encoding(s, ns)
}

var error abnf.Operator

// Error rule: error = 1*NQSCHAR
func Error(s []byte, ns abnf.Nodes) abnf.Nodes {
	if error == nil {
		error = abnf.Repeat1Inf("error", NQSCHAR)
	}
	return error(s, ns)
}

var errorInfo abnf.Operator

// ErrorInfo rule: Error-Info = "Error-Info" HCOLON error-uri *(COMMA error-uri)
func ErrorInfo(s []byte, ns abnf.Nodes) abnf.Nodes {
	if errorInfo == nil {
		errorInfo = abnf.Concat(
			"Error-Info",
			abnf.Literal("\"Error-Info\"", []byte{69, 114, 114, 111, 114, 45, 73, 110, 102, 111}),
			HCOLON,
			ErrorUri,
			abnf.Repeat0Inf("*(COMMA error-uri)", abnf.Concat(
				"COMMA error-uri",
				COMMA,
				ErrorUri,
			)),
		)
	}
	return errorInfo(s, ns)
}

var errorParam abnf.Operator

// ErrorParam rule: error-param = "error" EQUAL DQUOTE error DQUOTE
func ErrorParam(s []byte, ns abnf.Nodes) abnf.Nodes {
	if errorParam == nil {
		errorParam = abnf.Concat(
			"error-param",
			abnf.Literal("\"error\"", []byte{101, 114, 114, 111, 114}),
			EQUAL,
			abnf_core.DQUOTE,
			Error,
			abnf_core.DQUOTE,
		)
	}
	return errorParam(s, ns)
}

var errorUri abnf.Operator

// ErrorUri rule: error-uri = LAQUOT absoluteURI RAQUOT *( SEMI generic-param )
func ErrorUri(s []byte, ns abnf.Nodes) abnf.Nodes {
	if errorUri == nil {
		errorUri = abnf.Concat(
			"error-uri",
			LAQUOT,
			AbsoluteURI,
			RAQUOT,
			abnf.Repeat0Inf("*( SEMI generic-param )", abnf.Concat(
				"SEMI generic-param",
				SEMI,
				GenericParam,
			)),
		)
	}
	return errorUri(s, ns)
}

var escaped abnf.Operator

// Escaped rule: escaped = "%" HEXDIG HEXDIG
func Escaped(s []byte, ns abnf.Nodes) abnf.Nodes {
	if escaped == nil {
		escaped = abnf.Concat(
			"escaped",
			abnf.Literal("\"%\"", []byte{37}),
			abnf_core.HEXDIG,
			abnf_core.HEXDIG,
		)
	}
	return escaped(s, ns)
}

var expires abnf.Operator

// Expires rule: Expires = "Expires" HCOLON delta-seconds
func Expires(s []byte, ns abnf.Nodes) abnf.Nodes {
	if expires == nil {
		expires = abnf.Concat(
			"Expires",
			abnf.Literal("\"Expires\"", []byte{69, 120, 112, 105, 114, 101, 115}),
			HCOLON,
			DeltaSeconds,
		)
	}
	return expires(s, ns)
}

var extensionCode abnf.Operator

// ExtensionCode rule: extension-code = 3DIGIT
func ExtensionCode(s []byte, ns abnf.Nodes) abnf.Nodes {
	if extensionCode == nil {
		extensionCode = abnf.RepeatN("extension-code", uint(0x3), abnf_core.DIGIT)
	}
	return extensionCode(s, ns)
}

var extensionHeader abnf.Operator

// ExtensionHeader rule: extension-header = header-name HCOLON header-value
func ExtensionHeader(s []byte, ns abnf.Nodes) abnf.Nodes {
	if extensionHeader == nil {
		extensionHeader = abnf.Concat(
			"extension-header",
			HeaderName,
			HCOLON,
			HeaderValue,
		)
	}
	return extensionHeader(s, ns)
}

var extensionMethod abnf.Operator

// ExtensionMethod rule: extension-method = token
func ExtensionMethod(s []byte, ns abnf.Nodes) abnf.Nodes {
	if extensionMethod == nil {
		extensionMethod = Token
	}
	return extensionMethod(s, ns)
}

var extensionToken abnf.Operator

// ExtensionToken rule: extension-token = ietf-token / x-token
func ExtensionToken(s []byte, ns abnf.Nodes) abnf.Nodes {
	if extensionToken == nil {
		extensionToken = abnf.Alt(
			"extension-token",
			IetfToken,
			XToken,
		)
	}
	return extensionToken(s, ns)
}

var from abnf.Operator

// From rule: From = ( "From" / "f" ) HCOLON from-spec
func From(s []byte, ns abnf.Nodes) abnf.Nodes {
	if from == nil {
		from = abnf.Concat(
			"From",
			abnf.Alt(
				"\"From\" / \"f\"",
				abnf.Literal("\"From\"", []byte{70, 114, 111, 109}),
				abnf.Literal("\"f\"", []byte{102}),
			),
			HCOLON,
			FromSpec,
		)
	}
	return from(s, ns)
}

var fromParam abnf.Operator

// FromParam rule: from-param = tag-param / generic-param
func FromParam(s []byte, ns abnf.Nodes) abnf.Nodes {
	if fromParam == nil {
		fromParam = abnf.Alt(
			"from-param",
			TagParam,
			GenericParam,
		)
	}
	return fromParam(s, ns)
}

var fromSpec abnf.Operator

// FromSpec rule: from-spec = ( name-addr / addr-spec ) *( SEMI from-param )
func FromSpec(s []byte, ns abnf.Nodes) abnf.Nodes {
	if fromSpec == nil {
		fromSpec = abnf.Concat(
			"from-spec",
			abnf.Alt(
				"name-addr / addr-spec",
				NameAddr,
				AddrSpec,
			),
			abnf.Repeat0Inf("*( SEMI from-param )", abnf.Concat(
				"SEMI from-param",
				SEMI,
				FromParam,
			)),
		)
	}
	return fromSpec(s, ns)
}

var genValue abnf.Operator

// GenValue rule: gen-value = token / host / quoted-string
func GenValue(s []byte, ns abnf.Nodes) abnf.Nodes {
	if genValue == nil {
		genValue = abnf.Alt(
			"gen-value",
			Token,
			Host,
			QuotedString,
		)
	}
	return genValue(s, ns)
}

var genericParam abnf.Operator

// GenericParam rule: generic-param = token [ EQUAL gen-value ]
func GenericParam(s []byte, ns abnf.Nodes) abnf.Nodes {
	if genericParam == nil {
		genericParam = abnf.Concat(
			"generic-param",
			Token,
			abnf.Optional("[ EQUAL gen-value ]", abnf.Concat(
				"EQUAL gen-value",
				EQUAL,
				GenValue,
			)),
		)
	}
	return genericParam(s, ns)
}

var globalFailure abnf.Operator

// GlobalFailure rule: Global-Failure = "600" ; Busy Everywhere / "603" ; Decline / "604" ; Does not exist anywhere / "606"
func GlobalFailure(s []byte, ns abnf.Nodes) abnf.Nodes {
	if globalFailure == nil {
		globalFailure = abnf.Alt(
			"Global-Failure",
			abnf.Literal("\"600\"", []byte{54, 48, 48}),
			abnf.Literal("\"603\"", []byte{54, 48, 51}),
			abnf.Literal("\"604\"", []byte{54, 48, 52}),
			abnf.Literal("\"606\"", []byte{54, 48, 54}),
		)
	}
	return globalFailure(s, ns)
}

var h16 abnf.Operator

// H16 rule: h16 = 1*4HEXDIG
func H16(s []byte, ns abnf.Nodes) abnf.Nodes {
	if h16 == nil {
		h16 = abnf.Repeat("h16", uint(0x1), uint(0x4), abnf_core.HEXDIG)
	}
	return h16(s, ns)
}

var hcolon abnf.Operator

// HCOLON rule: HCOLON = *( SP / HTAB ) ":" SWS
func HCOLON(s []byte, ns abnf.Nodes) abnf.Nodes {
	if hcolon == nil {
		hcolon = abnf.Concat(
			"HCOLON",
			abnf.Repeat0Inf("*( SP / HTAB )", abnf.Alt(
				"SP / HTAB",
				abnf_core.SP,
				abnf_core.HTAB,
			)),
			abnf.Literal("\":\"", []byte{58}),
			SWS,
		)
	}
	return hcolon(s, ns)
}

var handlingParam abnf.Operator

// HandlingParam rule: handling-param = "handling" EQUAL ( "optional" / "required" / other-handling )
func HandlingParam(s []byte, ns abnf.Nodes) abnf.Nodes {
	if handlingParam == nil {
		handlingParam = abnf.Concat(
			"handling-param",
			abnf.Literal("\"handling\"", []byte{104, 97, 110, 100, 108, 105, 110, 103}),
			EQUAL,
			abnf.Alt(
				"\"optional\" / \"required\" / other-handling",
				abnf.Literal("\"optional\"", []byte{111, 112, 116, 105, 111, 110, 97, 108}),
				abnf.Literal("\"required\"", []byte{114, 101, 113, 117, 105, 114, 101, 100}),
				OtherHandling,
			),
		)
	}
	return handlingParam(s, ns)
}

var header abnf.Operator

// Header rule: header = hname "=" hvalue
func Header(s []byte, ns abnf.Nodes) abnf.Nodes {
	if header == nil {
		header = abnf.Concat(
			"header",
			Hname,
			abnf.Literal("\"=\"", []byte{61}),
			Hvalue,
		)
	}
	return header(s, ns)
}

var headerName abnf.Operator

// HeaderName rule: header-name = token
func HeaderName(s []byte, ns abnf.Nodes) abnf.Nodes {
	if headerName == nil {
		headerName = Token
	}
	return headerName(s, ns)
}

var headerValue abnf.Operator

// HeaderValue rule: header-value = *(TEXT-UTF8char / UTF8-CONT / LWS)
func HeaderValue(s []byte, ns abnf.Nodes) abnf.Nodes {
	if headerValue == nil {
		headerValue = abnf.Repeat0Inf("header-value", abnf.Alt(
			"TEXT-UTF8char / UTF8-CONT / LWS",
			TEXTUTF8char,
			UTF8CONT,
			LWS,
		))
	}
	return headerValue(s, ns)
}

var headers abnf.Operator

// Headers rule: headers = "?" header *( "&" header )
func Headers(s []byte, ns abnf.Nodes) abnf.Nodes {
	if headers == nil {
		headers = abnf.Concat(
			"headers",
			abnf.Literal("\"?\"", []byte{63}),
			Header,
			abnf.Repeat0Inf("*( \"&\" header )", abnf.Concat(
				"\"&\" header",
				abnf.Literal("\"&\"", []byte{38}),
				Header,
			)),
		)
	}
	return headers(s, ns)
}

var hierPart abnf.Operator

// HierPart rule: hier-part = ( net-path / abs-path ) [ "?" query ]
func HierPart(s []byte, ns abnf.Nodes) abnf.Nodes {
	if hierPart == nil {
		hierPart = abnf.Concat(
			"hier-part",
			abnf.Alt(
				"net-path / abs-path",
				NetPath,
				AbsPath,
			),
			abnf.Optional("[ \"?\" query ]", abnf.Concat(
				"\"?\" query",
				abnf.Literal("\"?\"", []byte{63}),
				Query,
			)),
		)
	}
	return hierPart(s, ns)
}

var hname abnf.Operator

// Hname rule: hname = 1*( hnv-unreserved / unreserved / escaped )
func Hname(s []byte, ns abnf.Nodes) abnf.Nodes {
	if hname == nil {
		hname = abnf.Repeat1Inf("hname", abnf.Alt(
			"hnv-unreserved / unreserved / escaped",
			HnvUnreserved,
			Unreserved,
			Escaped,
		))
	}
	return hname(s, ns)
}

var hnvUnreserved abnf.Operator

// HnvUnreserved rule: hnv-unreserved = "[" / "]" / "/" / "?" / ":" / "+" / "$"
func HnvUnreserved(s []byte, ns abnf.Nodes) abnf.Nodes {
	if hnvUnreserved == nil {
		hnvUnreserved = abnf.Alt(
			"hnv-unreserved",
			abnf.Literal("\"[\"", []byte{91}),
			abnf.Literal("\"]\"", []byte{93}),
			abnf.Literal("\"/\"", []byte{47}),
			abnf.Literal("\"?\"", []byte{63}),
			abnf.Literal("\":\"", []byte{58}),
			abnf.Literal("\"+\"", []byte{43}),
			abnf.Literal("\"$\"", []byte{36}),
		)
	}
	return hnvUnreserved(s, ns)
}

var host abnf.Operator

// Host rule: host = hostname / IPv4address / IPv6reference
func Host(s []byte, ns abnf.Nodes) abnf.Nodes {
	if host == nil {
		host = abnf.Alt(
			"host",
			Hostname,
			IPv4address,
			IPv6reference,
		)
	}
	return host(s, ns)
}

var hostname abnf.Operator

// Hostname rule: hostname = *( domainlabel "." ) toplabel [ "." ]
func Hostname(s []byte, ns abnf.Nodes) abnf.Nodes {
	if hostname == nil {
		hostname = abnf.Concat(
			"hostname",
			abnf.Repeat0Inf("*( domainlabel \".\" )", abnf.Concat(
				"domainlabel \".\"",
				Domainlabel,
				abnf.Literal("\".\"", []byte{46}),
			)),
			Toplabel,
			abnf.Optional("[ \".\" ]", abnf.Literal("\".\"", []byte{46})),
		)
	}
	return hostname(s, ns)
}

var hostport abnf.Operator

// Hostport rule: hostport = host [ ":" port ]
func Hostport(s []byte, ns abnf.Nodes) abnf.Nodes {
	if hostport == nil {
		hostport = abnf.Concat(
			"hostport",
			Host,
			abnf.Optional("[ \":\" port ]", abnf.Concat(
				"\":\" port",
				abnf.Literal("\":\"", []byte{58}),
				Port,
			)),
		)
	}
	return hostport(s, ns)
}

var hvalue abnf.Operator

// Hvalue rule: hvalue = *( hnv-unreserved / unreserved / escaped )
func Hvalue(s []byte, ns abnf.Nodes) abnf.Nodes {
	if hvalue == nil {
		hvalue = abnf.Repeat0Inf("hvalue", abnf.Alt(
			"hnv-unreserved / unreserved / escaped",
			HnvUnreserved,
			Unreserved,
			Escaped,
		))
	}
	return hvalue(s, ns)
}

var invitem abnf.Operator

// INVITEm rule: INVITEm = %x49.4E.56.49.54.45
func INVITEm(s []byte, ns abnf.Nodes) abnf.Nodes {
	if invitem == nil {
		invitem = abnf.Literal("INVITEm", []byte{73, 78, 86, 73, 84, 69})
	}
	return invitem(s, ns)
}

var ipv4address abnf.Operator

// IPv4address rule: IPv4address = dec-octet "." dec-octet "." dec-octet "." dec-octet
func IPv4address(s []byte, ns abnf.Nodes) abnf.Nodes {
	if ipv4address == nil {
		ipv4address = abnf.Concat(
			"IPv4address",
			DecOctet,
			abnf.Literal("\".\"", []byte{46}),
			DecOctet,
			abnf.Literal("\".\"", []byte{46}),
			DecOctet,
			abnf.Literal("\".\"", []byte{46}),
			DecOctet,
		)
	}
	return ipv4address(s, ns)
}

var ipv6address abnf.Operator

// IPv6address rule: IPv6address = 6( h16 ":" ) ls32 / "::" 5( h16 ":" ) ls32 / [ h16 ] "::" 4( h16 ":" ) ls32 / [ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32 / [ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32 / [ *3( h16 ":" ) h16 ] "::" h16 ":" ls32 / [ *4( h16 ":" ) h16 ] "::" ls32 / [ *5( h16 ":" ) h16 ] "::" h16 / [ *6( h16 ":" ) h16 ] "::"
func IPv6address(s []byte, ns abnf.Nodes) abnf.Nodes {
	if ipv6address == nil {
		ipv6address = abnf.Alt(
			"IPv6address",
			abnf.Concat(
				"6( h16 \":\" ) ls32",
				abnf.RepeatN("6( h16 \":\" )", uint(0x6), abnf.Concat(
					"h16 \":\"",
					H16,
					abnf.Literal("\":\"", []byte{58}),
				)),
				Ls32,
			),
			abnf.Concat(
				"\"::\" 5( h16 \":\" ) ls32",
				abnf.Literal("\"::\"", []byte{58, 58}),
				abnf.RepeatN("5( h16 \":\" )", uint(0x5), abnf.Concat(
					"h16 \":\"",
					H16,
					abnf.Literal("\":\"", []byte{58}),
				)),
				Ls32,
			),
			abnf.Concat(
				"[ h16 ] \"::\" 4( h16 \":\" ) ls32",
				abnf.Optional("[ h16 ]", H16),
				abnf.Literal("\"::\"", []byte{58, 58}),
				abnf.RepeatN("4( h16 \":\" )", uint(0x4), abnf.Concat(
					"h16 \":\"",
					H16,
					abnf.Literal("\":\"", []byte{58}),
				)),
				Ls32,
			),
			abnf.Concat(
				"[ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32",
				abnf.Optional("[ *1( h16 \":\" ) h16 ]", abnf.Concat(
					"*1( h16 \":\" ) h16",
					abnf.Repeat("*1( h16 \":\" )", uint(0x0), uint(0x1), abnf.Concat(
						"h16 \":\"",
						H16,
						abnf.Literal("\":\"", []byte{58}),
					)),
					H16,
				)),
				abnf.Literal("\"::\"", []byte{58, 58}),
				abnf.RepeatN("3( h16 \":\" )", uint(0x3), abnf.Concat(
					"h16 \":\"",
					H16,
					abnf.Literal("\":\"", []byte{58}),
				)),
				Ls32,
			),
			abnf.Concat(
				"[ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32",
				abnf.Optional("[ *2( h16 \":\" ) h16 ]", abnf.Concat(
					"*2( h16 \":\" ) h16",
					abnf.Repeat("*2( h16 \":\" )", uint(0x0), uint(0x2), abnf.Concat(
						"h16 \":\"",
						H16,
						abnf.Literal("\":\"", []byte{58}),
					)),
					H16,
				)),
				abnf.Literal("\"::\"", []byte{58, 58}),
				abnf.RepeatN("2( h16 \":\" )", uint(0x2), abnf.Concat(
					"h16 \":\"",
					H16,
					abnf.Literal("\":\"", []byte{58}),
				)),
				Ls32,
			),
			abnf.Concat(
				"[ *3( h16 \":\" ) h16 ] \"::\" h16 \":\" ls32",
				abnf.Optional("[ *3( h16 \":\" ) h16 ]", abnf.Concat(
					"*3( h16 \":\" ) h16",
					abnf.Repeat("*3( h16 \":\" )", uint(0x0), uint(0x3), abnf.Concat(
						"h16 \":\"",
						H16,
						abnf.Literal("\":\"", []byte{58}),
					)),
					H16,
				)),
				abnf.Literal("\"::\"", []byte{58, 58}),
				H16,
				abnf.Literal("\":\"", []byte{58}),
				Ls32,
			),
			abnf.Concat(
				"[ *4( h16 \":\" ) h16 ] \"::\" ls32",
				abnf.Optional("[ *4( h16 \":\" ) h16 ]", abnf.Concat(
					"*4( h16 \":\" ) h16",
					abnf.Repeat("*4( h16 \":\" )", uint(0x0), uint(0x4), abnf.Concat(
						"h16 \":\"",
						H16,
						abnf.Literal("\":\"", []byte{58}),
					)),
					H16,
				)),
				abnf.Literal("\"::\"", []byte{58, 58}),
				Ls32,
			),
			abnf.Concat(
				"[ *5( h16 \":\" ) h16 ] \"::\" h16",
				abnf.Optional("[ *5( h16 \":\" ) h16 ]", abnf.Concat(
					"*5( h16 \":\" ) h16",
					abnf.Repeat("*5( h16 \":\" )", uint(0x0), uint(0x5), abnf.Concat(
						"h16 \":\"",
						H16,
						abnf.Literal("\":\"", []byte{58}),
					)),
					H16,
				)),
				abnf.Literal("\"::\"", []byte{58, 58}),
				H16,
			),
			abnf.Concat(
				"[ *6( h16 \":\" ) h16 ] \"::\"",
				abnf.Optional("[ *6( h16 \":\" ) h16 ]", abnf.Concat(
					"*6( h16 \":\" ) h16",
					abnf.Repeat("*6( h16 \":\" )", uint(0x0), uint(0x6), abnf.Concat(
						"h16 \":\"",
						H16,
						abnf.Literal("\":\"", []byte{58}),
					)),
					H16,
				)),
				abnf.Literal("\"::\"", []byte{58, 58}),
			),
		)
	}
	return ipv6address(s, ns)
}

var ipv6reference abnf.Operator

// IPv6reference rule: IPv6reference = "[" IPv6address "]"
func IPv6reference(s []byte, ns abnf.Nodes) abnf.Nodes {
	if ipv6reference == nil {
		ipv6reference = abnf.Concat(
			"IPv6reference",
			abnf.Literal("\"[\"", []byte{91}),
			IPv6address,
			abnf.Literal("\"]\"", []byte{93}),
		)
	}
	return ipv6reference(s, ns)
}

var ianaToken abnf.Operator

// IanaToken rule: iana-token = token
func IanaToken(s []byte, ns abnf.Nodes) abnf.Nodes {
	if ianaToken == nil {
		ianaToken = Token
	}
	return ianaToken(s, ns)
}

var ietfToken abnf.Operator

// IetfToken rule: ietf-token = token
func IetfToken(s []byte, ns abnf.Nodes) abnf.Nodes {
	if ietfToken == nil {
		ietfToken = Token
	}
	return ietfToken(s, ns)
}

var inReplyTo abnf.Operator

// InReplyTo rule: In-Reply-To = "In-Reply-To" HCOLON callid *(COMMA callid)
func InReplyTo(s []byte, ns abnf.Nodes) abnf.Nodes {
	if inReplyTo == nil {
		inReplyTo = abnf.Concat(
			"In-Reply-To",
			abnf.Literal("\"In-Reply-To\"", []byte{73, 110, 45, 82, 101, 112, 108, 121, 45, 84, 111}),
			HCOLON,
			Callid,
			abnf.Repeat0Inf("*(COMMA callid)", abnf.Concat(
				"COMMA callid",
				COMMA,
				Callid,
			)),
		)
	}
	return inReplyTo(s, ns)
}

var info abnf.Operator

// Info rule: info = LAQUOT absoluteURI RAQUOT *( SEMI info-param)
func Info(s []byte, ns abnf.Nodes) abnf.Nodes {
	if info == nil {
		info = abnf.Concat(
			"info",
			LAQUOT,
			AbsoluteURI,
			RAQUOT,
			abnf.Repeat0Inf("*( SEMI info-param)", abnf.Concat(
				"SEMI info-param",
				SEMI,
				InfoParam,
			)),
		)
	}
	return info(s, ns)
}

var infoParam abnf.Operator

// InfoParam rule: info-param = ( "purpose" EQUAL ( "icon" / "info" / "card" / token ) ) / generic-param
func InfoParam(s []byte, ns abnf.Nodes) abnf.Nodes {
	if infoParam == nil {
		infoParam = abnf.Alt(
			"info-param",
			abnf.Concat(
				"\"purpose\" EQUAL ( \"icon\" / \"info\" / \"card\" / token )",
				abnf.Literal("\"purpose\"", []byte{112, 117, 114, 112, 111, 115, 101}),
				EQUAL,
				abnf.Alt(
					"\"icon\" / \"info\" / \"card\" / token",
					abnf.Literal("\"icon\"", []byte{105, 99, 111, 110}),
					abnf.Literal("\"info\"", []byte{105, 110, 102, 111}),
					abnf.Literal("\"card\"", []byte{99, 97, 114, 100}),
					Token,
				),
			),
			GenericParam,
		)
	}
	return infoParam(s, ns)
}

var informational abnf.Operator

// Informational rule: Informational = "100" ; Trying / "180" ; Ringing / "181" ; Call Is Being Forwarded / "182" ; Queued / "183"
func Informational(s []byte, ns abnf.Nodes) abnf.Nodes {
	if informational == nil {
		informational = abnf.Alt(
			"Informational",
			abnf.Literal("\"100\"", []byte{49, 48, 48}),
			abnf.Literal("\"180\"", []byte{49, 56, 48}),
			abnf.Literal("\"181\"", []byte{49, 56, 49}),
			abnf.Literal("\"182\"", []byte{49, 56, 50}),
			abnf.Literal("\"183\"", []byte{49, 56, 51}),
		)
	}
	return informational(s, ns)
}

var laquot abnf.Operator

// LAQUOT rule: LAQUOT = SWS "<"
func LAQUOT(s []byte, ns abnf.Nodes) abnf.Nodes {
	if laquot == nil {
		laquot = abnf.Concat(
			"LAQUOT",
			SWS,
			abnf.Literal("\"<\"", []byte{60}),
		)
	}
	return laquot(s, ns)
}

var ldquot abnf.Operator

// LDQUOT rule: LDQUOT = SWS DQUOTE
func LDQUOT(s []byte, ns abnf.Nodes) abnf.Nodes {
	if ldquot == nil {
		ldquot = abnf.Concat(
			"LDQUOT",
			SWS,
			abnf_core.DQUOTE,
		)
	}
	return ldquot(s, ns)
}

var lhex abnf.Operator

// LHEX rule: LHEX = DIGIT / %x61-66
func LHEX(s []byte, ns abnf.Nodes) abnf.Nodes {
	if lhex == nil {
		lhex = abnf.Alt(
			"LHEX",
			abnf_core.DIGIT,
			abnf.Range("%x61-66", []byte{97}, []byte{102}),
		)
	}
	return lhex(s, ns)
}

var lparen abnf.Operator

// LPAREN rule: LPAREN = SWS "(" SWS
func LPAREN(s []byte, ns abnf.Nodes) abnf.Nodes {
	if lparen == nil {
		lparen = abnf.Concat(
			"LPAREN",
			SWS,
			abnf.Literal("\"(\"", []byte{40}),
			SWS,
		)
	}
	return lparen(s, ns)
}

var lws abnf.Operator

// LWS rule: LWS = [*WSP CRLF] 1*WSP
func LWS(s []byte, ns abnf.Nodes) abnf.Nodes {
	if lws == nil {
		lws = abnf.Concat(
			"LWS",
			abnf.Optional("[*WSP CRLF]", abnf.Concat(
				"*WSP CRLF",
				abnf.Repeat0Inf("*WSP", abnf_core.WSP),
				abnf_core.CRLF,
			)),
			abnf.Repeat1Inf("1*WSP", abnf_core.WSP),
		)
	}
	return lws(s, ns)
}

var language abnf.Operator

// Language rule: language = language-range *(SEMI accept-param)
func Language(s []byte, ns abnf.Nodes) abnf.Nodes {
	if language == nil {
		language = abnf.Concat(
			"language",
			LanguageRange,
			abnf.Repeat0Inf("*(SEMI accept-param)", abnf.Concat(
				"SEMI accept-param",
				SEMI,
				AcceptParam,
			)),
		)
	}
	return language(s, ns)
}

var languageRange abnf.Operator

// LanguageRange rule: language-range = ( 1*8ALPHA *( "-" 1*8ALPHA ) ) / "*"
func LanguageRange(s []byte, ns abnf.Nodes) abnf.Nodes {
	if languageRange == nil {
		languageRange = abnf.Alt(
			"language-range",
			abnf.Concat(
				"1*8ALPHA *( \"-\" 1*8ALPHA )",
				abnf.Repeat("1*8ALPHA", uint(0x1), uint(0x8), abnf_core.ALPHA),
				abnf.Repeat0Inf("*( \"-\" 1*8ALPHA )", abnf.Concat(
					"\"-\" 1*8ALPHA",
					abnf.Literal("\"-\"", []byte{45}),
					abnf.Repeat("1*8ALPHA", uint(0x1), uint(0x8), abnf_core.ALPHA),
				)),
			),
			abnf.Literal("\"*\"", []byte{42}),
		)
	}
	return languageRange(s, ns)
}

var languageTag abnf.Operator

// LanguageTag rule: language-tag = primary-tag *( "-" subtag )
func LanguageTag(s []byte, ns abnf.Nodes) abnf.Nodes {
	if languageTag == nil {
		languageTag = abnf.Concat(
			"language-tag",
			PrimaryTag,
			abnf.Repeat0Inf("*( \"-\" subtag )", abnf.Concat(
				"\"-\" subtag",
				abnf.Literal("\"-\"", []byte{45}),
				Subtag,
			)),
		)
	}
	return languageTag(s, ns)
}

var lrParam abnf.Operator

// LrParam rule: lr-param = "lr"
func LrParam(s []byte, ns abnf.Nodes) abnf.Nodes {
	if lrParam == nil {
		lrParam = abnf.Literal("lr-param", []byte{108, 114})
	}
	return lrParam(s, ns)
}

var ls32 abnf.Operator

// Ls32 rule: ls32 = ( h16 ":" h16 ) / IPv4address
func Ls32(s []byte, ns abnf.Nodes) abnf.Nodes {
	if ls32 == nil {
		ls32 = abnf.Alt(
			"ls32",
			abnf.Concat(
				"h16 \":\" h16",
				H16,
				abnf.Literal("\":\"", []byte{58}),
				H16,
			),
			IPv4address,
		)
	}
	return ls32(s, ns)
}

var mAttribute abnf.Operator

// MAttribute rule: m-attribute = token
func MAttribute(s []byte, ns abnf.Nodes) abnf.Nodes {
	if mAttribute == nil {
		mAttribute = Token
	}
	return mAttribute(s, ns)
}

var mimeVersion abnf.Operator

// MIMEVersion rule: MIME-Version = "MIME-Version" HCOLON 1*DIGIT "." 1*DIGIT
func MIMEVersion(s []byte, ns abnf.Nodes) abnf.Nodes {
	if mimeVersion == nil {
		mimeVersion = abnf.Concat(
			"MIME-Version",
			abnf.Literal("\"MIME-Version\"", []byte{77, 73, 77, 69, 45, 86, 101, 114, 115, 105, 111, 110}),
			HCOLON,
			abnf.Repeat1Inf("1*DIGIT", abnf_core.DIGIT),
			abnf.Literal("\".\"", []byte{46}),
			abnf.Repeat1Inf("1*DIGIT", abnf_core.DIGIT),
		)
	}
	return mimeVersion(s, ns)
}

var mParameter abnf.Operator

// MParameter rule: m-parameter = m-attribute EQUAL m-value
func MParameter(s []byte, ns abnf.Nodes) abnf.Nodes {
	if mParameter == nil {
		mParameter = abnf.Concat(
			"m-parameter",
			MAttribute,
			EQUAL,
			MValue,
		)
	}
	return mParameter(s, ns)
}

var mSubtype abnf.Operator

// MSubtype rule: m-subtype = extension-token / iana-token
func MSubtype(s []byte, ns abnf.Nodes) abnf.Nodes {
	if mSubtype == nil {
		mSubtype = abnf.Alt(
			"m-subtype",
			ExtensionToken,
			IanaToken,
		)
	}
	return mSubtype(s, ns)
}

var mType abnf.Operator

// MType rule: m-type = discrete-type / composite-type
func MType(s []byte, ns abnf.Nodes) abnf.Nodes {
	if mType == nil {
		mType = abnf.Alt(
			"m-type",
			DiscreteType,
			CompositeType,
		)
	}
	return mType(s, ns)
}

var mValue abnf.Operator

// MValue rule: m-value = token / quoted-string
func MValue(s []byte, ns abnf.Nodes) abnf.Nodes {
	if mValue == nil {
		mValue = abnf.Alt(
			"m-value",
			Token,
			QuotedString,
		)
	}
	return mValue(s, ns)
}

var maddrParam abnf.Operator

// MaddrParam rule: maddr-param = "maddr=" host
func MaddrParam(s []byte, ns abnf.Nodes) abnf.Nodes {
	if maddrParam == nil {
		maddrParam = abnf.Concat(
			"maddr-param",
			abnf.Literal("\"maddr=\"", []byte{109, 97, 100, 100, 114, 61}),
			Host,
		)
	}
	return maddrParam(s, ns)
}

var mark abnf.Operator

// Mark rule: mark = "-" / "_" / "." / "!" / "~" / "*" / "'" / "(" / ")"
func Mark(s []byte, ns abnf.Nodes) abnf.Nodes {
	if mark == nil {
		mark = abnf.Alt(
			"mark",
			abnf.Literal("\"-\"", []byte{45}),
			abnf.Literal("\"_\"", []byte{95}),
			abnf.Literal("\".\"", []byte{46}),
			abnf.Literal("\"!\"", []byte{33}),
			abnf.Literal("\"~\"", []byte{126}),
			abnf.Literal("\"*\"", []byte{42}),
			abnf.Literal("\"'\"", []byte{39}),
			abnf.Literal("\"(\"", []byte{40}),
			abnf.Literal("\")\"", []byte{41}),
		)
	}
	return mark(s, ns)
}

var maxForwards abnf.Operator

// MaxForwards rule: Max-Forwards = "Max-Forwards" HCOLON 1*DIGIT
func MaxForwards(s []byte, ns abnf.Nodes) abnf.Nodes {
	if maxForwards == nil {
		maxForwards = abnf.Concat(
			"Max-Forwards",
			abnf.Literal("\"Max-Forwards\"", []byte{77, 97, 120, 45, 70, 111, 114, 119, 97, 114, 100, 115}),
			HCOLON,
			abnf.Repeat1Inf("1*DIGIT", abnf_core.DIGIT),
		)
	}
	return maxForwards(s, ns)
}

var mediaRange abnf.Operator

// MediaRange rule: media-range = ( "*/*" / ( m-type SLASH "*" ) / ( m-type SLASH m-subtype ) ) *( SEMI m-parameter )
func MediaRange(s []byte, ns abnf.Nodes) abnf.Nodes {
	if mediaRange == nil {
		mediaRange = abnf.Concat(
			"media-range",
			abnf.Alt(
				"\"*/*\" / ( m-type SLASH \"*\" ) / ( m-type SLASH m-subtype )",
				abnf.Literal("\"*/*\"", []byte{42, 47, 42}),
				abnf.Concat(
					"m-type SLASH \"*\"",
					MType,
					SLASH,
					abnf.Literal("\"*\"", []byte{42}),
				),
				abnf.Concat(
					"m-type SLASH m-subtype",
					MType,
					SLASH,
					MSubtype,
				),
			),
			abnf.Repeat0Inf("*( SEMI m-parameter )", abnf.Concat(
				"SEMI m-parameter",
				SEMI,
				MParameter,
			)),
		)
	}
	return mediaRange(s, ns)
}

var mediaType abnf.Operator

// MediaType rule: media-type = m-type SLASH m-subtype *(SEMI m-parameter)
func MediaType(s []byte, ns abnf.Nodes) abnf.Nodes {
	if mediaType == nil {
		mediaType = abnf.Concat(
			"media-type",
			MType,
			SLASH,
			MSubtype,
			abnf.Repeat0Inf("*(SEMI m-parameter)", abnf.Concat(
				"SEMI m-parameter",
				SEMI,
				MParameter,
			)),
		)
	}
	return mediaType(s, ns)
}

var messageBody abnf.Operator

// MessageBody rule: message-body = *OCTET
func MessageBody(s []byte, ns abnf.Nodes) abnf.Nodes {
	if messageBody == nil {
		messageBody = abnf.Repeat0Inf("message-body", abnf_core.OCTET)
	}
	return messageBody(s, ns)
}

var messageHeader abnf.Operator

// MessageHeader rule: message-header = (Accept / Accept-Encoding / Accept-Language / Alert-Info / Allow / Authentication-Info / Authorization / Call-ID / Call-Info / Contact / Content-Disposition / Content-Encoding / Content-Language / Content-Length / Content-Type / CSeq / Date / Error-Info / Expires / From / In-Reply-To / Max-Forwards / MIME-Version / Min-Expires / Organization / Priority / Proxy-Authenticate / Proxy-Authorization / Proxy-Require / Record-Route / Reply-To / Require / Retry-After / Route / Server / Subject / Supported / Timestamp / To / Unsupported / User-Agent / Via / Warning / WWW-Authenticate / extension-header) CRLF
func MessageHeader(s []byte, ns abnf.Nodes) abnf.Nodes {
	if messageHeader == nil {
		messageHeader = abnf.Concat(
			"message-header",
			abnf.Alt(
				"Accept / Accept-Encoding / Accept-Language / Alert-Info / Allow / Authentication-Info / Authorization / Call-ID / Call-Info / Contact / Content-Disposition / Content-Encoding / Content-Language / Content-Length / Content-Type / CSeq / Date / Error-Info / Expires / From / In-Reply-To / Max-Forwards / MIME-Version / Min-Expires / Organization / Priority / Proxy-Authenticate / Proxy-Authorization / Proxy-Require / Record-Route / Reply-To / Require / Retry-After / Route / Server / Subject / Supported / Timestamp / To / Unsupported / User-Agent / Via / Warning / WWW-Authenticate / extension-header",
				Accept,
				AcceptEncoding,
				AcceptLanguage,
				AlertInfo,
				Allow,
				AuthenticationInfo,
				Authorization,
				CallID,
				CallInfo,
				Contact,
				ContentDisposition,
				ContentEncoding,
				ContentLanguage,
				ContentLength,
				ContentType,
				CSeq,
				Date,
				ErrorInfo,
				Expires,
				From,
				InReplyTo,
				MaxForwards,
				MIMEVersion,
				MinExpires,
				Organization,
				Priority,
				ProxyAuthenticate,
				ProxyAuthorization,
				ProxyRequire,
				RecordRoute,
				ReplyTo,
				Require,
				RetryAfter,
				Route,
				Server,
				Subject,
				Supported,
				Timestamp,
				To,
				Unsupported,
				UserAgent,
				Via,
				Warning,
				WWWAuthenticate,
				ExtensionHeader,
			),
			abnf_core.CRLF,
		)
	}
	return messageHeader(s, ns)
}

var messageQop abnf.Operator

// MessageQop rule: message-qop = "qop" EQUAL qop-value
func MessageQop(s []byte, ns abnf.Nodes) abnf.Nodes {
	if messageQop == nil {
		messageQop = abnf.Concat(
			"message-qop",
			abnf.Literal("\"qop\"", []byte{113, 111, 112}),
			EQUAL,
			QopValue,
		)
	}
	return messageQop(s, ns)
}

var method abnf.Operator

// Method rule: Method = INVITEm / ACKm / OPTIONSm / BYEm / CANCELm / REGISTERm / extension-method
func Method(s []byte, ns abnf.Nodes) abnf.Nodes {
	if method == nil {
		method = abnf.Alt(
			"Method",
			INVITEm,
			ACKm,
			OPTIONSm,
			BYEm,
			CANCELm,
			REGISTERm,
			ExtensionMethod,
		)
	}
	return method(s, ns)
}

var methodParam abnf.Operator

// MethodParam rule: method-param = "method=" Method
func MethodParam(s []byte, ns abnf.Nodes) abnf.Nodes {
	if methodParam == nil {
		methodParam = abnf.Concat(
			"method-param",
			abnf.Literal("\"method=\"", []byte{109, 101, 116, 104, 111, 100, 61}),
			Method,
		)
	}
	return methodParam(s, ns)
}

var minExpires abnf.Operator

// MinExpires rule: Min-Expires = "Min-Expires" HCOLON delta-seconds
func MinExpires(s []byte, ns abnf.Nodes) abnf.Nodes {
	if minExpires == nil {
		minExpires = abnf.Concat(
			"Min-Expires",
			abnf.Literal("\"Min-Expires\"", []byte{77, 105, 110, 45, 69, 120, 112, 105, 114, 101, 115}),
			HCOLON,
			DeltaSeconds,
		)
	}
	return minExpires(s, ns)
}

var month abnf.Operator

// Month rule: month = "Jan" / "Feb" / "Mar" / "Apr" / "May" / "Jun" / "Jul" / "Aug" / "Sep" / "Oct" / "Nov" / "Dec"
func Month(s []byte, ns abnf.Nodes) abnf.Nodes {
	if month == nil {
		month = abnf.Alt(
			"month",
			abnf.Literal("\"Jan\"", []byte{74, 97, 110}),
			abnf.Literal("\"Feb\"", []byte{70, 101, 98}),
			abnf.Literal("\"Mar\"", []byte{77, 97, 114}),
			abnf.Literal("\"Apr\"", []byte{65, 112, 114}),
			abnf.Literal("\"May\"", []byte{77, 97, 121}),
			abnf.Literal("\"Jun\"", []byte{74, 117, 110}),
			abnf.Literal("\"Jul\"", []byte{74, 117, 108}),
			abnf.Literal("\"Aug\"", []byte{65, 117, 103}),
			abnf.Literal("\"Sep\"", []byte{83, 101, 112}),
			abnf.Literal("\"Oct\"", []byte{79, 99, 116}),
			abnf.Literal("\"Nov\"", []byte{78, 111, 118}),
			abnf.Literal("\"Dec\"", []byte{68, 101, 99}),
		)
	}
	return month(s, ns)
}

var nqchar abnf.Operator

// NQCHAR rule: NQCHAR = %x21 / %x23-5B / %x5D-7E
func NQCHAR(s []byte, ns abnf.Nodes) abnf.Nodes {
	if nqchar == nil {
		nqchar = abnf.Alt(
			"NQCHAR",
			abnf.Literal("%x21", []byte{33}),
			abnf.Range("%x23-5B", []byte{35}, []byte{91}),
			abnf.Range("%x5D-7E", []byte{93}, []byte{126}),
		)
	}
	return nqchar(s, ns)
}

var nqschar abnf.Operator

// NQSCHAR rule: NQSCHAR = %x20-21 / %x23-5B / %x5D-7E
func NQSCHAR(s []byte, ns abnf.Nodes) abnf.Nodes {
	if nqschar == nil {
		nqschar = abnf.Alt(
			"NQSCHAR",
			abnf.Range("%x20-21", []byte{32}, []byte{33}),
			abnf.Range("%x23-5B", []byte{35}, []byte{91}),
			abnf.Range("%x5D-7E", []byte{93}, []byte{126}),
		)
	}
	return nqschar(s, ns)
}

var nameAddr abnf.Operator

// NameAddr rule: name-addr = [ display-name ] LAQUOT addr-spec RAQUOT
func NameAddr(s []byte, ns abnf.Nodes) abnf.Nodes {
	if nameAddr == nil {
		nameAddr = abnf.Concat(
			"name-addr",
			abnf.Optional("[ display-name ]", DisplayName),
			LAQUOT,
			AddrSpec,
			RAQUOT,
		)
	}
	return nameAddr(s, ns)
}

var ncValue abnf.Operator

// NcValue rule: nc-value = 8LHEX
func NcValue(s []byte, ns abnf.Nodes) abnf.Nodes {
	if ncValue == nil {
		ncValue = abnf.RepeatN("nc-value", uint(0x8), LHEX)
	}
	return ncValue(s, ns)
}

var netPath abnf.Operator

// NetPath rule: net-path = "//" authority [ abs-path ]
func NetPath(s []byte, ns abnf.Nodes) abnf.Nodes {
	if netPath == nil {
		netPath = abnf.Concat(
			"net-path",
			abnf.Literal("\"//\"", []byte{47, 47}),
			Authority,
			abnf.Optional("[ abs-path ]", AbsPath),
		)
	}
	return netPath(s, ns)
}

var nextnonce abnf.Operator

// Nextnonce rule: nextnonce = "nextnonce" EQUAL nonce-value
func Nextnonce(s []byte, ns abnf.Nodes) abnf.Nodes {
	if nextnonce == nil {
		nextnonce = abnf.Concat(
			"nextnonce",
			abnf.Literal("\"nextnonce\"", []byte{110, 101, 120, 116, 110, 111, 110, 99, 101}),
			EQUAL,
			NonceValue,
		)
	}
	return nextnonce(s, ns)
}

var nonce abnf.Operator

// Nonce rule: nonce = "nonce" EQUAL nonce-value
func Nonce(s []byte, ns abnf.Nodes) abnf.Nodes {
	if nonce == nil {
		nonce = abnf.Concat(
			"nonce",
			abnf.Literal("\"nonce\"", []byte{110, 111, 110, 99, 101}),
			EQUAL,
			NonceValue,
		)
	}
	return nonce(s, ns)
}

var nonceCount abnf.Operator

// NonceCount rule: nonce-count = "nc" EQUAL nc-value
func NonceCount(s []byte, ns abnf.Nodes) abnf.Nodes {
	if nonceCount == nil {
		nonceCount = abnf.Concat(
			"nonce-count",
			abnf.Literal("\"nc\"", []byte{110, 99}),
			EQUAL,
			NcValue,
		)
	}
	return nonceCount(s, ns)
}

var nonceValue abnf.Operator

// NonceValue rule: nonce-value = quoted-string
func NonceValue(s []byte, ns abnf.Nodes) abnf.Nodes {
	if nonceValue == nil {
		nonceValue = QuotedString
	}
	return nonceValue(s, ns)
}

var optionsm abnf.Operator

// OPTIONSm rule: OPTIONSm = %x4F.50.54.49.4F.4E.53
func OPTIONSm(s []byte, ns abnf.Nodes) abnf.Nodes {
	if optionsm == nil {
		optionsm = abnf.Literal("OPTIONSm", []byte{79, 80, 84, 73, 79, 78, 83})
	}
	return optionsm(s, ns)
}

var opaque abnf.Operator

// Opaque rule: opaque = "opaque" EQUAL quoted-string
func Opaque(s []byte, ns abnf.Nodes) abnf.Nodes {
	if opaque == nil {
		opaque = abnf.Concat(
			"opaque",
			abnf.Literal("\"opaque\"", []byte{111, 112, 97, 113, 117, 101}),
			EQUAL,
			QuotedString,
		)
	}
	return opaque(s, ns)
}

var opaquePart abnf.Operator

// OpaquePart rule: opaque-part = uric-no-slash *uric
func OpaquePart(s []byte, ns abnf.Nodes) abnf.Nodes {
	if opaquePart == nil {
		opaquePart = abnf.Concat(
			"opaque-part",
			UricNoSlash,
			abnf.Repeat0Inf("*uric", Uric),
		)
	}
	return opaquePart(s, ns)
}

var optionTag abnf.Operator

// OptionTag rule: option-tag = token
func OptionTag(s []byte, ns abnf.Nodes) abnf.Nodes {
	if optionTag == nil {
		optionTag = Token
	}
	return optionTag(s, ns)
}

var organization abnf.Operator

// Organization rule: Organization = "Organization" HCOLON [TEXT-UTF8-TRIM]
func Organization(s []byte, ns abnf.Nodes) abnf.Nodes {
	if organization == nil {
		organization = abnf.Concat(
			"Organization",
			abnf.Literal("\"Organization\"", []byte{79, 114, 103, 97, 110, 105, 122, 97, 116, 105, 111, 110}),
			HCOLON,
			abnf.Optional("[TEXT-UTF8-TRIM]", TEXTUTF8TRIM),
		)
	}
	return organization(s, ns)
}

var otherChallenge abnf.Operator

// OtherChallenge rule: other-challenge = auth-scheme LWS auth-param *(COMMA auth-param)
func OtherChallenge(s []byte, ns abnf.Nodes) abnf.Nodes {
	if otherChallenge == nil {
		otherChallenge = abnf.Concat(
			"other-challenge",
			AuthScheme,
			LWS,
			AuthParam,
			abnf.Repeat0Inf("*(COMMA auth-param)", abnf.Concat(
				"COMMA auth-param",
				COMMA,
				AuthParam,
			)),
		)
	}
	return otherChallenge(s, ns)
}

var otherHandling abnf.Operator

// OtherHandling rule: other-handling = token
func OtherHandling(s []byte, ns abnf.Nodes) abnf.Nodes {
	if otherHandling == nil {
		otherHandling = Token
	}
	return otherHandling(s, ns)
}

var otherParam abnf.Operator

// OtherParam rule: other-param = pname [ "=" pvalue ]
func OtherParam(s []byte, ns abnf.Nodes) abnf.Nodes {
	if otherParam == nil {
		otherParam = abnf.Concat(
			"other-param",
			Pname,
			abnf.Optional("[ \"=\" pvalue ]", abnf.Concat(
				"\"=\" pvalue",
				abnf.Literal("\"=\"", []byte{61}),
				Pvalue,
			)),
		)
	}
	return otherParam(s, ns)
}

var otherPriority abnf.Operator

// OtherPriority rule: other-priority = token
func OtherPriority(s []byte, ns abnf.Nodes) abnf.Nodes {
	if otherPriority == nil {
		otherPriority = Token
	}
	return otherPriority(s, ns)
}

var otherResponse abnf.Operator

// OtherResponse rule: other-response = auth-scheme LWS auth-param *(COMMA auth-param)
func OtherResponse(s []byte, ns abnf.Nodes) abnf.Nodes {
	if otherResponse == nil {
		otherResponse = abnf.Concat(
			"other-response",
			AuthScheme,
			LWS,
			AuthParam,
			abnf.Repeat0Inf("*(COMMA auth-param)", abnf.Concat(
				"COMMA auth-param",
				COMMA,
				AuthParam,
			)),
		)
	}
	return otherResponse(s, ns)
}

var otherTransport abnf.Operator

// OtherTransport rule: other-transport = token
func OtherTransport(s []byte, ns abnf.Nodes) abnf.Nodes {
	if otherTransport == nil {
		otherTransport = Token
	}
	return otherTransport(s, ns)
}

var otherUser abnf.Operator

// OtherUser rule: other-user = token
func OtherUser(s []byte, ns abnf.Nodes) abnf.Nodes {
	if otherUser == nil {
		otherUser = Token
	}
	return otherUser(s, ns)
}

var param abnf.Operator

// Param rule: param = *pchar
func Param(s []byte, ns abnf.Nodes) abnf.Nodes {
	if param == nil {
		param = abnf.Repeat0Inf("param", Pchar)
	}
	return param(s, ns)
}

var paramUnreserved abnf.Operator

// ParamUnreserved rule: param-unreserved = "[" / "]" / "/" / ":" / "&" / "+" / "$"
func ParamUnreserved(s []byte, ns abnf.Nodes) abnf.Nodes {
	if paramUnreserved == nil {
		paramUnreserved = abnf.Alt(
			"param-unreserved",
			abnf.Literal("\"[\"", []byte{91}),
			abnf.Literal("\"]\"", []byte{93}),
			abnf.Literal("\"/\"", []byte{47}),
			abnf.Literal("\":\"", []byte{58}),
			abnf.Literal("\"&\"", []byte{38}),
			abnf.Literal("\"+\"", []byte{43}),
			abnf.Literal("\"$\"", []byte{36}),
		)
	}
	return paramUnreserved(s, ns)
}

var paramchar abnf.Operator

// Paramchar rule: paramchar = param-unreserved / unreserved / escaped
func Paramchar(s []byte, ns abnf.Nodes) abnf.Nodes {
	if paramchar == nil {
		paramchar = abnf.Alt(
			"paramchar",
			ParamUnreserved,
			Unreserved,
			Escaped,
		)
	}
	return paramchar(s, ns)
}

var password abnf.Operator

// Password rule: password = *( unreserved / escaped / "&" / "=" / "+" / "$" / "," )
func Password(s []byte, ns abnf.Nodes) abnf.Nodes {
	if password == nil {
		password = abnf.Repeat0Inf("password", abnf.Alt(
			"unreserved / escaped / \"&\" / \"=\" / \"+\" / \"$\" / \",\"",
			Unreserved,
			Escaped,
			abnf.Literal("\"&\"", []byte{38}),
			abnf.Literal("\"=\"", []byte{61}),
			abnf.Literal("\"+\"", []byte{43}),
			abnf.Literal("\"$\"", []byte{36}),
			abnf.Literal("\",\"", []byte{44}),
		))
	}
	return password(s, ns)
}

var pathSegments abnf.Operator

// PathSegments rule: path-segments = segment *( "/" segment )
func PathSegments(s []byte, ns abnf.Nodes) abnf.Nodes {
	if pathSegments == nil {
		pathSegments = abnf.Concat(
			"path-segments",
			Segment,
			abnf.Repeat0Inf("*( \"/\" segment )", abnf.Concat(
				"\"/\" segment",
				abnf.Literal("\"/\"", []byte{47}),
				Segment,
			)),
		)
	}
	return pathSegments(s, ns)
}

var pchar abnf.Operator

// Pchar rule: pchar = unreserved / escaped / ":" / "@" / "&" / "=" / "+" / "$" / ","
func Pchar(s []byte, ns abnf.Nodes) abnf.Nodes {
	if pchar == nil {
		pchar = abnf.Alt(
			"pchar",
			Unreserved,
			Escaped,
			abnf.Literal("\":\"", []byte{58}),
			abnf.Literal("\"@\"", []byte{64}),
			abnf.Literal("\"&\"", []byte{38}),
			abnf.Literal("\"=\"", []byte{61}),
			abnf.Literal("\"+\"", []byte{43}),
			abnf.Literal("\"$\"", []byte{36}),
			abnf.Literal("\",\"", []byte{44}),
		)
	}
	return pchar(s, ns)
}

var pname abnf.Operator

// Pname rule: pname = 1*paramchar
func Pname(s []byte, ns abnf.Nodes) abnf.Nodes {
	if pname == nil {
		pname = abnf.Repeat1Inf("pname", Paramchar)
	}
	return pname(s, ns)
}

var port abnf.Operator

// Port rule: port = 1*DIGIT
func Port(s []byte, ns abnf.Nodes) abnf.Nodes {
	if port == nil {
		port = abnf.Repeat1Inf("port", abnf_core.DIGIT)
	}
	return port(s, ns)
}

var primaryTag abnf.Operator

// PrimaryTag rule: primary-tag = 1*8ALPHA
func PrimaryTag(s []byte, ns abnf.Nodes) abnf.Nodes {
	if primaryTag == nil {
		primaryTag = abnf.Repeat("primary-tag", uint(0x1), uint(0x8), abnf_core.ALPHA)
	}
	return primaryTag(s, ns)
}

var priority abnf.Operator

// Priority rule: Priority = "Priority" HCOLON priority-value
func Priority(s []byte, ns abnf.Nodes) abnf.Nodes {
	if priority == nil {
		priority = abnf.Concat(
			"Priority",
			abnf.Literal("\"Priority\"", []byte{80, 114, 105, 111, 114, 105, 116, 121}),
			HCOLON,
			PriorityValue,
		)
	}
	return priority(s, ns)
}

var priorityValue abnf.Operator

// PriorityValue rule: priority-value = "emergency" / "urgent" / "normal" / "non-urgent" / other-priority
func PriorityValue(s []byte, ns abnf.Nodes) abnf.Nodes {
	if priorityValue == nil {
		priorityValue = abnf.Alt(
			"priority-value",
			abnf.Literal("\"emergency\"", []byte{101, 109, 101, 114, 103, 101, 110, 99, 121}),
			abnf.Literal("\"urgent\"", []byte{117, 114, 103, 101, 110, 116}),
			abnf.Literal("\"normal\"", []byte{110, 111, 114, 109, 97, 108}),
			abnf.Literal("\"non-urgent\"", []byte{110, 111, 110, 45, 117, 114, 103, 101, 110, 116}),
			OtherPriority,
		)
	}
	return priorityValue(s, ns)
}

var product abnf.Operator

// Product rule: product = token [SLASH product-version]
func Product(s []byte, ns abnf.Nodes) abnf.Nodes {
	if product == nil {
		product = abnf.Concat(
			"product",
			Token,
			abnf.Optional("[SLASH product-version]", abnf.Concat(
				"SLASH product-version",
				SLASH,
				ProductVersion,
			)),
		)
	}
	return product(s, ns)
}

var productVersion abnf.Operator

// ProductVersion rule: product-version = token
func ProductVersion(s []byte, ns abnf.Nodes) abnf.Nodes {
	if productVersion == nil {
		productVersion = Token
	}
	return productVersion(s, ns)
}

var protocolName abnf.Operator

// ProtocolName rule: protocol-name = "SIP" / token
func ProtocolName(s []byte, ns abnf.Nodes) abnf.Nodes {
	if protocolName == nil {
		protocolName = abnf.Alt(
			"protocol-name",
			abnf.Literal("\"SIP\"", []byte{83, 73, 80}),
			Token,
		)
	}
	return protocolName(s, ns)
}

var protocolVersion abnf.Operator

// ProtocolVersion rule: protocol-version = token
func ProtocolVersion(s []byte, ns abnf.Nodes) abnf.Nodes {
	if protocolVersion == nil {
		protocolVersion = Token
	}
	return protocolVersion(s, ns)
}

var proxyAuthenticate abnf.Operator

// ProxyAuthenticate rule: Proxy-Authenticate = "Proxy-Authenticate" HCOLON challenge
func ProxyAuthenticate(s []byte, ns abnf.Nodes) abnf.Nodes {
	if proxyAuthenticate == nil {
		proxyAuthenticate = abnf.Concat(
			"Proxy-Authenticate",
			abnf.Literal("\"Proxy-Authenticate\"", []byte{80, 114, 111, 120, 121, 45, 65, 117, 116, 104, 101, 110, 116, 105, 99, 97, 116, 101}),
			HCOLON,
			Challenge,
		)
	}
	return proxyAuthenticate(s, ns)
}

var proxyAuthorization abnf.Operator

// ProxyAuthorization rule: Proxy-Authorization = "Proxy-Authorization" HCOLON credentials
func ProxyAuthorization(s []byte, ns abnf.Nodes) abnf.Nodes {
	if proxyAuthorization == nil {
		proxyAuthorization = abnf.Concat(
			"Proxy-Authorization",
			abnf.Literal("\"Proxy-Authorization\"", []byte{80, 114, 111, 120, 121, 45, 65, 117, 116, 104, 111, 114, 105, 122, 97, 116, 105, 111, 110}),
			HCOLON,
			Credentials,
		)
	}
	return proxyAuthorization(s, ns)
}

var proxyRequire abnf.Operator

// ProxyRequire rule: Proxy-Require = "Proxy-Require" HCOLON option-tag *(COMMA option-tag)
func ProxyRequire(s []byte, ns abnf.Nodes) abnf.Nodes {
	if proxyRequire == nil {
		proxyRequire = abnf.Concat(
			"Proxy-Require",
			abnf.Literal("\"Proxy-Require\"", []byte{80, 114, 111, 120, 121, 45, 82, 101, 113, 117, 105, 114, 101}),
			HCOLON,
			OptionTag,
			abnf.Repeat0Inf("*(COMMA option-tag)", abnf.Concat(
				"COMMA option-tag",
				COMMA,
				OptionTag,
			)),
		)
	}
	return proxyRequire(s, ns)
}

var pseudonym abnf.Operator

// Pseudonym rule: pseudonym = token
func Pseudonym(s []byte, ns abnf.Nodes) abnf.Nodes {
	if pseudonym == nil {
		pseudonym = Token
	}
	return pseudonym(s, ns)
}

var pvalue abnf.Operator

// Pvalue rule: pvalue = 1*paramchar
func Pvalue(s []byte, ns abnf.Nodes) abnf.Nodes {
	if pvalue == nil {
		pvalue = abnf.Repeat1Inf("pvalue", Paramchar)
	}
	return pvalue(s, ns)
}

var qdtext abnf.Operator

// Qdtext rule: qdtext = LWS / %x21 / %x23-5B / %x5D-7E / UTF8-NONASCII
func Qdtext(s []byte, ns abnf.Nodes) abnf.Nodes {
	if qdtext == nil {
		qdtext = abnf.Alt(
			"qdtext",
			LWS,
			abnf.Literal("%x21", []byte{33}),
			abnf.Range("%x23-5B", []byte{35}, []byte{91}),
			abnf.Range("%x5D-7E", []byte{93}, []byte{126}),
			UTF8NONASCII,
		)
	}
	return qdtext(s, ns)
}

var qopOptions abnf.Operator

// QopOptions rule: qop-options = "qop" EQUAL LDQUOT qop-value *("," qop-value) RDQUOT
func QopOptions(s []byte, ns abnf.Nodes) abnf.Nodes {
	if qopOptions == nil {
		qopOptions = abnf.Concat(
			"qop-options",
			abnf.Literal("\"qop\"", []byte{113, 111, 112}),
			EQUAL,
			LDQUOT,
			QopValue,
			abnf.Repeat0Inf("*(\",\" qop-value)", abnf.Concat(
				"\",\" qop-value",
				abnf.Literal("\",\"", []byte{44}),
				QopValue,
			)),
			RDQUOT,
		)
	}
	return qopOptions(s, ns)
}

var qopValue abnf.Operator

// QopValue rule: qop-value = "auth" / "auth-int" / token
func QopValue(s []byte, ns abnf.Nodes) abnf.Nodes {
	if qopValue == nil {
		qopValue = abnf.Alt(
			"qop-value",
			abnf.Literal("\"auth\"", []byte{97, 117, 116, 104}),
			abnf.Literal("\"auth-int\"", []byte{97, 117, 116, 104, 45, 105, 110, 116}),
			Token,
		)
	}
	return qopValue(s, ns)
}

var query abnf.Operator

// Query rule: query = *uric
func Query(s []byte, ns abnf.Nodes) abnf.Nodes {
	if query == nil {
		query = abnf.Repeat0Inf("query", Uric)
	}
	return query(s, ns)
}

var quotedPair abnf.Operator

// QuotedPair rule: quoted-pair = "\" (%x00-09 / %x0B-0C / %x0E-7F)
func QuotedPair(s []byte, ns abnf.Nodes) abnf.Nodes {
	if quotedPair == nil {
		quotedPair = abnf.Concat(
			"quoted-pair",
			abnf.Literal("\"\\\\\"", []byte{92}),
			abnf.Alt(
				"%x00-09 / %x0B-0C / %x0E-7F",
				abnf.Range("%x00-09", []byte{0}, []byte{9}),
				abnf.Range("%x0B-0C", []byte{11}, []byte{12}),
				abnf.Range("%x0E-7F", []byte{14}, []byte{127}),
			),
		)
	}
	return quotedPair(s, ns)
}

var quotedString abnf.Operator

// QuotedString rule: quoted-string = SWS DQUOTE *(qdtext / quoted-pair ) DQUOTE
func QuotedString(s []byte, ns abnf.Nodes) abnf.Nodes {
	if quotedString == nil {
		quotedString = abnf.Concat(
			"quoted-string",
			SWS,
			abnf_core.DQUOTE,
			abnf.Repeat0Inf("*(qdtext / quoted-pair )", abnf.Alt(
				"qdtext / quoted-pair",
				Qdtext,
				QuotedPair,
			)),
			abnf_core.DQUOTE,
		)
	}
	return quotedString(s, ns)
}

var qvalue abnf.Operator

// Qvalue rule: qvalue = ( "0" [ "." 0*3DIGIT ] ) / ( "1" [ "." 0*3("0") ] )
func Qvalue(s []byte, ns abnf.Nodes) abnf.Nodes {
	if qvalue == nil {
		qvalue = abnf.Alt(
			"qvalue",
			abnf.Concat(
				"\"0\" [ \".\" 0*3DIGIT ]",
				abnf.Literal("\"0\"", []byte{48}),
				abnf.Optional("[ \".\" 0*3DIGIT ]", abnf.Concat(
					"\".\" 0*3DIGIT",
					abnf.Literal("\".\"", []byte{46}),
					abnf.Repeat("0*3DIGIT", uint(0x0), uint(0x3), abnf_core.DIGIT),
				)),
			),
			abnf.Concat(
				"\"1\" [ \".\" 0*3(\"0\") ]",
				abnf.Literal("\"1\"", []byte{49}),
				abnf.Optional("[ \".\" 0*3(\"0\") ]", abnf.Concat(
					"\".\" 0*3(\"0\")",
					abnf.Literal("\".\"", []byte{46}),
					abnf.Repeat("0*3(\"0\")", uint(0x0), uint(0x3), abnf.Literal("\"0\"", []byte{48})),
				)),
			),
		)
	}
	return qvalue(s, ns)
}

var raquot abnf.Operator

// RAQUOT rule: RAQUOT = ">" SWS
func RAQUOT(s []byte, ns abnf.Nodes) abnf.Nodes {
	if raquot == nil {
		raquot = abnf.Concat(
			"RAQUOT",
			abnf.Literal("\">\"", []byte{62}),
			SWS,
		)
	}
	return raquot(s, ns)
}

var rdquot abnf.Operator

// RDQUOT rule: RDQUOT = DQUOTE SWS
func RDQUOT(s []byte, ns abnf.Nodes) abnf.Nodes {
	if rdquot == nil {
		rdquot = abnf.Concat(
			"RDQUOT",
			abnf_core.DQUOTE,
			SWS,
		)
	}
	return rdquot(s, ns)
}

var registerm abnf.Operator

// REGISTERm rule: REGISTERm = %x52.45.47.49.53.54.45.52
func REGISTERm(s []byte, ns abnf.Nodes) abnf.Nodes {
	if registerm == nil {
		registerm = abnf.Literal("REGISTERm", []byte{82, 69, 71, 73, 83, 84, 69, 82})
	}
	return registerm(s, ns)
}

var rparen abnf.Operator

// RPAREN rule: RPAREN = SWS ")" SWS
func RPAREN(s []byte, ns abnf.Nodes) abnf.Nodes {
	if rparen == nil {
		rparen = abnf.Concat(
			"RPAREN",
			SWS,
			abnf.Literal("\")\"", []byte{41}),
			SWS,
		)
	}
	return rparen(s, ns)
}

var realm abnf.Operator

// Realm rule: realm = "realm" EQUAL realm-value
func Realm(s []byte, ns abnf.Nodes) abnf.Nodes {
	if realm == nil {
		realm = abnf.Concat(
			"realm",
			abnf.Literal("\"realm\"", []byte{114, 101, 97, 108, 109}),
			EQUAL,
			RealmValue,
		)
	}
	return realm(s, ns)
}

var realmValue abnf.Operator

// RealmValue rule: realm-value = quoted-string
func RealmValue(s []byte, ns abnf.Nodes) abnf.Nodes {
	if realmValue == nil {
		realmValue = QuotedString
	}
	return realmValue(s, ns)
}

var reasonPhrase abnf.Operator

// ReasonPhrase rule: Reason-Phrase = *(reserved / unreserved / escaped / UTF8-NONASCII / UTF8-CONT / SP / HTAB)
func ReasonPhrase(s []byte, ns abnf.Nodes) abnf.Nodes {
	if reasonPhrase == nil {
		reasonPhrase = abnf.Repeat0Inf("Reason-Phrase", abnf.Alt(
			"reserved / unreserved / escaped / UTF8-NONASCII / UTF8-CONT / SP / HTAB",
			Reserved,
			Unreserved,
			Escaped,
			UTF8NONASCII,
			UTF8CONT,
			abnf_core.SP,
			abnf_core.HTAB,
		))
	}
	return reasonPhrase(s, ns)
}

var recRoute abnf.Operator

// RecRoute rule: rec-route = name-addr *( SEMI rr-param )
func RecRoute(s []byte, ns abnf.Nodes) abnf.Nodes {
	if recRoute == nil {
		recRoute = abnf.Concat(
			"rec-route",
			NameAddr,
			abnf.Repeat0Inf("*( SEMI rr-param )", abnf.Concat(
				"SEMI rr-param",
				SEMI,
				RrParam,
			)),
		)
	}
	return recRoute(s, ns)
}

var recordRoute abnf.Operator

// RecordRoute rule: Record-Route = "Record-Route" HCOLON rec-route *(COMMA rec-route)
func RecordRoute(s []byte, ns abnf.Nodes) abnf.Nodes {
	if recordRoute == nil {
		recordRoute = abnf.Concat(
			"Record-Route",
			abnf.Literal("\"Record-Route\"", []byte{82, 101, 99, 111, 114, 100, 45, 82, 111, 117, 116, 101}),
			HCOLON,
			RecRoute,
			abnf.Repeat0Inf("*(COMMA rec-route)", abnf.Concat(
				"COMMA rec-route",
				COMMA,
				RecRoute,
			)),
		)
	}
	return recordRoute(s, ns)
}

var redirection abnf.Operator

// Redirection rule: Redirection = "300" ; Multiple Choices / "301" ; Moved Permanently / "302" ; Moved Temporarily / "305" ; Use Proxy / "380"
func Redirection(s []byte, ns abnf.Nodes) abnf.Nodes {
	if redirection == nil {
		redirection = abnf.Alt(
			"Redirection",
			abnf.Literal("\"300\"", []byte{51, 48, 48}),
			abnf.Literal("\"301\"", []byte{51, 48, 49}),
			abnf.Literal("\"302\"", []byte{51, 48, 50}),
			abnf.Literal("\"305\"", []byte{51, 48, 53}),
			abnf.Literal("\"380\"", []byte{51, 56, 48}),
		)
	}
	return redirection(s, ns)
}

var regName abnf.Operator

// RegName rule: reg-name = 1*( unreserved / escaped / "$" / "," / ";" / ":" / "@" / "&" / "=" / "+" )
func RegName(s []byte, ns abnf.Nodes) abnf.Nodes {
	if regName == nil {
		regName = abnf.Repeat1Inf("reg-name", abnf.Alt(
			"unreserved / escaped / \"$\" / \",\" / \";\" / \":\" / \"@\" / \"&\" / \"=\" / \"+\"",
			Unreserved,
			Escaped,
			abnf.Literal("\"$\"", []byte{36}),
			abnf.Literal("\",\"", []byte{44}),
			abnf.Literal("\";\"", []byte{59}),
			abnf.Literal("\":\"", []byte{58}),
			abnf.Literal("\"@\"", []byte{64}),
			abnf.Literal("\"&\"", []byte{38}),
			abnf.Literal("\"=\"", []byte{61}),
			abnf.Literal("\"+\"", []byte{43}),
		))
	}
	return regName(s, ns)
}

var replyTo abnf.Operator

// ReplyTo rule: Reply-To = "Reply-To" HCOLON rplyto-spec
func ReplyTo(s []byte, ns abnf.Nodes) abnf.Nodes {
	if replyTo == nil {
		replyTo = abnf.Concat(
			"Reply-To",
			abnf.Literal("\"Reply-To\"", []byte{82, 101, 112, 108, 121, 45, 84, 111}),
			HCOLON,
			RplytoSpec,
		)
	}
	return replyTo(s, ns)
}

var request abnf.Operator

// Request rule: Request = Request-Line *( message-header ) CRLF [ message-body ]
func Request(s []byte, ns abnf.Nodes) abnf.Nodes {
	if request == nil {
		request = abnf.Concat(
			"Request",
			RequestLine,
			abnf.Repeat0Inf("*( message-header )", MessageHeader),
			abnf_core.CRLF,
			abnf.Optional("[ message-body ]", MessageBody),
		)
	}
	return request(s, ns)
}

var requestDigest abnf.Operator

// RequestDigest rule: request-digest = LDQUOT 32LHEX RDQUOT
func RequestDigest(s []byte, ns abnf.Nodes) abnf.Nodes {
	if requestDigest == nil {
		requestDigest = abnf.Concat(
			"request-digest",
			LDQUOT,
			abnf.RepeatN("32LHEX", uint(0x20), LHEX),
			RDQUOT,
		)
	}
	return requestDigest(s, ns)
}

var requestLine abnf.Operator

// RequestLine rule: Request-Line = Method SP Request-URI SP SIP-Version CRLF
func RequestLine(s []byte, ns abnf.Nodes) abnf.Nodes {
	if requestLine == nil {
		requestLine = abnf.Concat(
			"Request-Line",
			Method,
			abnf_core.SP,
			RequestURI,
			abnf_core.SP,
			SIPVersion,
			abnf_core.CRLF,
		)
	}
	return requestLine(s, ns)
}

var requestURI abnf.Operator

// RequestURI rule: Request-URI = SIP-URI / SIPS-URI / absoluteURI
func RequestURI(s []byte, ns abnf.Nodes) abnf.Nodes {
	if requestURI == nil {
		requestURI = abnf.Alt(
			"Request-URI",
			SIPURI,
			SIPSURI,
			AbsoluteURI,
		)
	}
	return requestURI(s, ns)
}

var requestUri abnf.Operator

// RequestUri rule: request-uri = Request-URI
func RequestUri(s []byte, ns abnf.Nodes) abnf.Nodes {
	if requestUri == nil {
		requestUri = RequestURI
	}
	return requestUri(s, ns)
}

var require abnf.Operator

// Require rule: Require = "Require" HCOLON option-tag *(COMMA option-tag)
func Require(s []byte, ns abnf.Nodes) abnf.Nodes {
	if require == nil {
		require = abnf.Concat(
			"Require",
			abnf.Literal("\"Require\"", []byte{82, 101, 113, 117, 105, 114, 101}),
			HCOLON,
			OptionTag,
			abnf.Repeat0Inf("*(COMMA option-tag)", abnf.Concat(
				"COMMA option-tag",
				COMMA,
				OptionTag,
			)),
		)
	}
	return require(s, ns)
}

var reserved abnf.Operator

// Reserved rule: reserved = ";" / "/" / "?" / ":" / "@" / "&" / "=" / "+" / "$" / ","
func Reserved(s []byte, ns abnf.Nodes) abnf.Nodes {
	if reserved == nil {
		reserved = abnf.Alt(
			"reserved",
			abnf.Literal("\";\"", []byte{59}),
			abnf.Literal("\"/\"", []byte{47}),
			abnf.Literal("\"?\"", []byte{63}),
			abnf.Literal("\":\"", []byte{58}),
			abnf.Literal("\"@\"", []byte{64}),
			abnf.Literal("\"&\"", []byte{38}),
			abnf.Literal("\"=\"", []byte{61}),
			abnf.Literal("\"+\"", []byte{43}),
			abnf.Literal("\"$\"", []byte{36}),
			abnf.Literal("\",\"", []byte{44}),
		)
	}
	return reserved(s, ns)
}

var response abnf.Operator

// Response rule: Response = Status-Line *( message-header ) CRLF [ message-body ]
func Response(s []byte, ns abnf.Nodes) abnf.Nodes {
	if response == nil {
		response = abnf.Concat(
			"Response",
			StatusLine,
			abnf.Repeat0Inf("*( message-header )", MessageHeader),
			abnf_core.CRLF,
			abnf.Optional("[ message-body ]", MessageBody),
		)
	}
	return response(s, ns)
}

var responseAuth abnf.Operator

// ResponseAuth rule: response-auth = "rspauth" EQUAL response-digest
func ResponseAuth(s []byte, ns abnf.Nodes) abnf.Nodes {
	if responseAuth == nil {
		responseAuth = abnf.Concat(
			"response-auth",
			abnf.Literal("\"rspauth\"", []byte{114, 115, 112, 97, 117, 116, 104}),
			EQUAL,
			ResponseDigest,
		)
	}
	return responseAuth(s, ns)
}

var responseDigest abnf.Operator

// ResponseDigest rule: response-digest = LDQUOT *LHEX RDQUOT
func ResponseDigest(s []byte, ns abnf.Nodes) abnf.Nodes {
	if responseDigest == nil {
		responseDigest = abnf.Concat(
			"response-digest",
			LDQUOT,
			abnf.Repeat0Inf("*LHEX", LHEX),
			RDQUOT,
		)
	}
	return responseDigest(s, ns)
}

var responsePort abnf.Operator

// ResponsePort rule: response-port = "rport" [EQUAL 1*DIGIT]
func ResponsePort(s []byte, ns abnf.Nodes) abnf.Nodes {
	if responsePort == nil {
		responsePort = abnf.Concat(
			"response-port",
			abnf.Literal("\"rport\"", []byte{114, 112, 111, 114, 116}),
			abnf.Optional("[EQUAL 1*DIGIT]", abnf.Concat(
				"EQUAL 1*DIGIT",
				EQUAL,
				abnf.Repeat1Inf("1*DIGIT", abnf_core.DIGIT),
			)),
		)
	}
	return responsePort(s, ns)
}

var retryAfter abnf.Operator

// RetryAfter rule: Retry-After = "Retry-After" HCOLON delta-seconds [ comment ] *( SEMI retry-param )
func RetryAfter(s []byte, ns abnf.Nodes) abnf.Nodes {
	if retryAfter == nil {
		retryAfter = abnf.Concat(
			"Retry-After",
			abnf.Literal("\"Retry-After\"", []byte{82, 101, 116, 114, 121, 45, 65, 102, 116, 101, 114}),
			HCOLON,
			DeltaSeconds,
			abnf.Optional("[ comment ]", Comment),
			abnf.Repeat0Inf("*( SEMI retry-param )", abnf.Concat(
				"SEMI retry-param",
				SEMI,
				RetryParam,
			)),
		)
	}
	return retryAfter(s, ns)
}

var retryParam abnf.Operator

// RetryParam rule: retry-param = ("duration" EQUAL delta-seconds) / generic-param
func RetryParam(s []byte, ns abnf.Nodes) abnf.Nodes {
	if retryParam == nil {
		retryParam = abnf.Alt(
			"retry-param",
			abnf.Concat(
				"\"duration\" EQUAL delta-seconds",
				abnf.Literal("\"duration\"", []byte{100, 117, 114, 97, 116, 105, 111, 110}),
				EQUAL,
				DeltaSeconds,
			),
			GenericParam,
		)
	}
	return retryParam(s, ns)
}

var rfc1123Date abnf.Operator

// Rfc1123Date rule: rfc1123-date = wkday "," SP date1 SP time SP "GMT"
func Rfc1123Date(s []byte, ns abnf.Nodes) abnf.Nodes {
	if rfc1123Date == nil {
		rfc1123Date = abnf.Concat(
			"rfc1123-date",
			Wkday,
			abnf.Literal("\",\"", []byte{44}),
			abnf_core.SP,
			Date1,
			abnf_core.SP,
			Time,
			abnf_core.SP,
			abnf.Literal("\"GMT\"", []byte{71, 77, 84}),
		)
	}
	return rfc1123Date(s, ns)
}

var route abnf.Operator

// Route rule: Route = "Route" HCOLON route-param *(COMMA route-param)
func Route(s []byte, ns abnf.Nodes) abnf.Nodes {
	if route == nil {
		route = abnf.Concat(
			"Route",
			abnf.Literal("\"Route\"", []byte{82, 111, 117, 116, 101}),
			HCOLON,
			RouteParam,
			abnf.Repeat0Inf("*(COMMA route-param)", abnf.Concat(
				"COMMA route-param",
				COMMA,
				RouteParam,
			)),
		)
	}
	return route(s, ns)
}

var routeParam abnf.Operator

// RouteParam rule: route-param = name-addr *( SEMI rr-param )
func RouteParam(s []byte, ns abnf.Nodes) abnf.Nodes {
	if routeParam == nil {
		routeParam = abnf.Concat(
			"route-param",
			NameAddr,
			abnf.Repeat0Inf("*( SEMI rr-param )", abnf.Concat(
				"SEMI rr-param",
				SEMI,
				RrParam,
			)),
		)
	}
	return routeParam(s, ns)
}

var rplytoParam abnf.Operator

// RplytoParam rule: rplyto-param = generic-param
func RplytoParam(s []byte, ns abnf.Nodes) abnf.Nodes {
	if rplytoParam == nil {
		rplytoParam = GenericParam
	}
	return rplytoParam(s, ns)
}

var rplytoSpec abnf.Operator

// RplytoSpec rule: rplyto-spec = ( name-addr / addr-spec ) *( SEMI rplyto-param )
func RplytoSpec(s []byte, ns abnf.Nodes) abnf.Nodes {
	if rplytoSpec == nil {
		rplytoSpec = abnf.Concat(
			"rplyto-spec",
			abnf.Alt(
				"name-addr / addr-spec",
				NameAddr,
				AddrSpec,
			),
			abnf.Repeat0Inf("*( SEMI rplyto-param )", abnf.Concat(
				"SEMI rplyto-param",
				SEMI,
				RplytoParam,
			)),
		)
	}
	return rplytoSpec(s, ns)
}

var rrParam abnf.Operator

// RrParam rule: rr-param = generic-param
func RrParam(s []byte, ns abnf.Nodes) abnf.Nodes {
	if rrParam == nil {
		rrParam = GenericParam
	}
	return rrParam(s, ns)
}

var semi abnf.Operator

// SEMI rule: SEMI = SWS ";" SWS
func SEMI(s []byte, ns abnf.Nodes) abnf.Nodes {
	if semi == nil {
		semi = abnf.Concat(
			"SEMI",
			SWS,
			abnf.Literal("\";\"", []byte{59}),
			SWS,
		)
	}
	return semi(s, ns)
}

var sipDate abnf.Operator

// SIPDate rule: SIP-date = rfc1123-date
func SIPDate(s []byte, ns abnf.Nodes) abnf.Nodes {
	if sipDate == nil {
		sipDate = Rfc1123Date
	}
	return sipDate(s, ns)
}

var sipMessage abnf.Operator

// SIPMessage rule: SIP-message = Request / Response
func SIPMessage(s []byte, ns abnf.Nodes) abnf.Nodes {
	if sipMessage == nil {
		sipMessage = abnf.Alt(
			"SIP-message",
			Request,
			Response,
		)
	}
	return sipMessage(s, ns)
}

var sipsURI abnf.Operator

// SIPSURI rule: SIPS-URI = "sips:" [ userinfo ] hostport uri-parameters [ headers ]
func SIPSURI(s []byte, ns abnf.Nodes) abnf.Nodes {
	if sipsURI == nil {
		sipsURI = abnf.Concat(
			"SIPS-URI",
			abnf.Literal("\"sips:\"", []byte{115, 105, 112, 115, 58}),
			abnf.Optional("[ userinfo ]", Userinfo),
			Hostport,
			UriParameters,
			abnf.Optional("[ headers ]", Headers),
		)
	}
	return sipsURI(s, ns)
}

var sipURI abnf.Operator

// SIPURI rule: SIP-URI = "sip:" [ userinfo ] hostport uri-parameters [ headers ]
func SIPURI(s []byte, ns abnf.Nodes) abnf.Nodes {
	if sipURI == nil {
		sipURI = abnf.Concat(
			"SIP-URI",
			abnf.Literal("\"sip:\"", []byte{115, 105, 112, 58}),
			abnf.Optional("[ userinfo ]", Userinfo),
			Hostport,
			UriParameters,
			abnf.Optional("[ headers ]", Headers),
		)
	}
	return sipURI(s, ns)
}

var sipVersion abnf.Operator

// SIPVersion rule: SIP-Version = "SIP" "/" 1*DIGIT "." 1*DIGIT
func SIPVersion(s []byte, ns abnf.Nodes) abnf.Nodes {
	if sipVersion == nil {
		sipVersion = abnf.Concat(
			"SIP-Version",
			abnf.Literal("\"SIP\"", []byte{83, 73, 80}),
			abnf.Literal("\"/\"", []byte{47}),
			abnf.Repeat1Inf("1*DIGIT", abnf_core.DIGIT),
			abnf.Literal("\".\"", []byte{46}),
			abnf.Repeat1Inf("1*DIGIT", abnf_core.DIGIT),
		)
	}
	return sipVersion(s, ns)
}

var slash abnf.Operator

// SLASH rule: SLASH = SWS "/" SWS
func SLASH(s []byte, ns abnf.Nodes) abnf.Nodes {
	if slash == nil {
		slash = abnf.Concat(
			"SLASH",
			SWS,
			abnf.Literal("\"/\"", []byte{47}),
			SWS,
		)
	}
	return slash(s, ns)
}

var star abnf.Operator

// STAR rule: STAR = SWS "*" SWS
func STAR(s []byte, ns abnf.Nodes) abnf.Nodes {
	if star == nil {
		star = abnf.Concat(
			"STAR",
			SWS,
			abnf.Literal("\"*\"", []byte{42}),
			SWS,
		)
	}
	return star(s, ns)
}

var sws abnf.Operator

// SWS rule: SWS = [LWS]
func SWS(s []byte, ns abnf.Nodes) abnf.Nodes {
	if sws == nil {
		sws = abnf.Optional("SWS", LWS)
	}
	return sws(s, ns)
}

var scheme abnf.Operator

// Scheme rule: scheme = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
func Scheme(s []byte, ns abnf.Nodes) abnf.Nodes {
	if scheme == nil {
		scheme = abnf.Concat(
			"scheme",
			abnf_core.ALPHA,
			abnf.Repeat0Inf("*( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )", abnf.Alt(
				"ALPHA / DIGIT / \"+\" / \"-\" / \".\"",
				abnf_core.ALPHA,
				abnf_core.DIGIT,
				abnf.Literal("\"+\"", []byte{43}),
				abnf.Literal("\"-\"", []byte{45}),
				abnf.Literal("\".\"", []byte{46}),
			)),
		)
	}
	return scheme(s, ns)
}

var scope abnf.Operator

// Scope rule: scope = scope-token *( SP scope-token )
func Scope(s []byte, ns abnf.Nodes) abnf.Nodes {
	if scope == nil {
		scope = abnf.Concat(
			"scope",
			ScopeToken,
			abnf.Repeat0Inf("*( SP scope-token )", abnf.Concat(
				"SP scope-token",
				abnf_core.SP,
				ScopeToken,
			)),
		)
	}
	return scope(s, ns)
}

var scopeParam abnf.Operator

// ScopeParam rule: scope-param = "scope" EQUAL DQUOTE scope DQUOTE
func ScopeParam(s []byte, ns abnf.Nodes) abnf.Nodes {
	if scopeParam == nil {
		scopeParam = abnf.Concat(
			"scope-param",
			abnf.Literal("\"scope\"", []byte{115, 99, 111, 112, 101}),
			EQUAL,
			abnf_core.DQUOTE,
			Scope,
			abnf_core.DQUOTE,
		)
	}
	return scopeParam(s, ns)
}

var scopeToken abnf.Operator

// ScopeToken rule: scope-token = 1*NQCHAR
func ScopeToken(s []byte, ns abnf.Nodes) abnf.Nodes {
	if scopeToken == nil {
		scopeToken = abnf.Repeat1Inf("scope-token", NQCHAR)
	}
	return scopeToken(s, ns)
}

var segment abnf.Operator

// Segment rule: segment = *pchar *( ";" param )
func Segment(s []byte, ns abnf.Nodes) abnf.Nodes {
	if segment == nil {
		segment = abnf.Concat(
			"segment",
			abnf.Repeat0Inf("*pchar", Pchar),
			abnf.Repeat0Inf("*( \";\" param )", abnf.Concat(
				"\";\" param",
				abnf.Literal("\";\"", []byte{59}),
				Param,
			)),
		)
	}
	return segment(s, ns)
}

var sentBy abnf.Operator

// SentBy rule: sent-by = host [ COLON port ]
func SentBy(s []byte, ns abnf.Nodes) abnf.Nodes {
	if sentBy == nil {
		sentBy = abnf.Concat(
			"sent-by",
			Host,
			abnf.Optional("[ COLON port ]", abnf.Concat(
				"COLON port",
				COLON,
				Port,
			)),
		)
	}
	return sentBy(s, ns)
}

var sentProtocol abnf.Operator

// SentProtocol rule: sent-protocol = protocol-name SLASH protocol-version SLASH transport
func SentProtocol(s []byte, ns abnf.Nodes) abnf.Nodes {
	if sentProtocol == nil {
		sentProtocol = abnf.Concat(
			"sent-protocol",
			ProtocolName,
			SLASH,
			ProtocolVersion,
			SLASH,
			Transport,
		)
	}
	return sentProtocol(s, ns)
}

var separators abnf.Operator

// Separators rule: separators = "(" / ")" / "<" / ">" / "@" / "," / ";" / ":" / "\" / DQUOTE / "/" / "[" / "]" / "?" / "=" / "{" / "}" / SP / HTAB
func Separators(s []byte, ns abnf.Nodes) abnf.Nodes {
	if separators == nil {
		separators = abnf.Alt(
			"separators",
			abnf.Literal("\"(\"", []byte{40}),
			abnf.Literal("\")\"", []byte{41}),
			abnf.Literal("\"<\"", []byte{60}),
			abnf.Literal("\">\"", []byte{62}),
			abnf.Literal("\"@\"", []byte{64}),
			abnf.Literal("\",\"", []byte{44}),
			abnf.Literal("\";\"", []byte{59}),
			abnf.Literal("\":\"", []byte{58}),
			abnf.Literal("\"\\\\\"", []byte{92}),
			abnf_core.DQUOTE,
			abnf.Literal("\"/\"", []byte{47}),
			abnf.Literal("\"[\"", []byte{91}),
			abnf.Literal("\"]\"", []byte{93}),
			abnf.Literal("\"?\"", []byte{63}),
			abnf.Literal("\"=\"", []byte{61}),
			abnf.Literal("\"{\"", []byte{123}),
			abnf.Literal("\"}\"", []byte{125}),
			abnf_core.SP,
			abnf_core.HTAB,
		)
	}
	return separators(s, ns)
}

var server abnf.Operator

// Server rule: Server = "Server" HCOLON server-val *(LWS server-val)
func Server(s []byte, ns abnf.Nodes) abnf.Nodes {
	if server == nil {
		server = abnf.Concat(
			"Server",
			abnf.Literal("\"Server\"", []byte{83, 101, 114, 118, 101, 114}),
			HCOLON,
			ServerVal,
			abnf.Repeat0Inf("*(LWS server-val)", abnf.Concat(
				"LWS server-val",
				LWS,
				ServerVal,
			)),
		)
	}
	return server(s, ns)
}

var serverError abnf.Operator

// ServerError rule: Server-Error = "500" ; Internal Server Error / "501" ; Not Implemented / "502" ; Bad Gateway / "503" ; Service Unavailable / "504" ; Server Time-out / "505" ; SIP Version not supported / "513"
func ServerError(s []byte, ns abnf.Nodes) abnf.Nodes {
	if serverError == nil {
		serverError = abnf.Alt(
			"Server-Error",
			abnf.Literal("\"500\"", []byte{53, 48, 48}),
			abnf.Literal("\"501\"", []byte{53, 48, 49}),
			abnf.Literal("\"502\"", []byte{53, 48, 50}),
			abnf.Literal("\"503\"", []byte{53, 48, 51}),
			abnf.Literal("\"504\"", []byte{53, 48, 52}),
			abnf.Literal("\"505\"", []byte{53, 48, 53}),
			abnf.Literal("\"513\"", []byte{53, 49, 51}),
		)
	}
	return serverError(s, ns)
}

var serverVal abnf.Operator

// ServerVal rule: server-val = product / comment
func ServerVal(s []byte, ns abnf.Nodes) abnf.Nodes {
	if serverVal == nil {
		serverVal = abnf.Alt(
			"server-val",
			Product,
			Comment,
		)
	}
	return serverVal(s, ns)
}

var srvr abnf.Operator

// Srvr rule: srvr = [ [ userinfo "@" ] hostport ]
func Srvr(s []byte, ns abnf.Nodes) abnf.Nodes {
	if srvr == nil {
		srvr = abnf.Optional("srvr", abnf.Concat(
			"[ userinfo \"@\" ] hostport",
			abnf.Optional("[ userinfo \"@\" ]", abnf.Concat(
				"userinfo \"@\"",
				Userinfo,
				abnf.Literal("\"@\"", []byte{64}),
			)),
			Hostport,
		))
	}
	return srvr(s, ns)
}

var stale abnf.Operator

// Stale rule: stale = "stale" EQUAL ( "true" / "false" )
func Stale(s []byte, ns abnf.Nodes) abnf.Nodes {
	if stale == nil {
		stale = abnf.Concat(
			"stale",
			abnf.Literal("\"stale\"", []byte{115, 116, 97, 108, 101}),
			EQUAL,
			abnf.Alt(
				"\"true\" / \"false\"",
				abnf.Literal("\"true\"", []byte{116, 114, 117, 101}),
				abnf.Literal("\"false\"", []byte{102, 97, 108, 115, 101}),
			),
		)
	}
	return stale(s, ns)
}

var statusCode abnf.Operator

// StatusCode rule: Status-Code = Informational / Redirection / Success / Client-Error / Server-Error / Global-Failure / extension-code
func StatusCode(s []byte, ns abnf.Nodes) abnf.Nodes {
	if statusCode == nil {
		statusCode = abnf.Alt(
			"Status-Code",
			Informational,
			Redirection,
			Success,
			ClientError,
			ServerError,
			GlobalFailure,
			ExtensionCode,
		)
	}
	return statusCode(s, ns)
}

var statusLine abnf.Operator

// StatusLine rule: Status-Line = SIP-Version SP Status-Code SP Reason-Phrase CRLF
func StatusLine(s []byte, ns abnf.Nodes) abnf.Nodes {
	if statusLine == nil {
		statusLine = abnf.Concat(
			"Status-Line",
			SIPVersion,
			abnf_core.SP,
			StatusCode,
			abnf_core.SP,
			ReasonPhrase,
			abnf_core.CRLF,
		)
	}
	return statusLine(s, ns)
}

var subject abnf.Operator

// Subject rule: Subject = ( "Subject" / "s" ) HCOLON [TEXT-UTF8-TRIM]
func Subject(s []byte, ns abnf.Nodes) abnf.Nodes {
	if subject == nil {
		subject = abnf.Concat(
			"Subject",
			abnf.Alt(
				"\"Subject\" / \"s\"",
				abnf.Literal("\"Subject\"", []byte{83, 117, 98, 106, 101, 99, 116}),
				abnf.Literal("\"s\"", []byte{115}),
			),
			HCOLON,
			abnf.Optional("[TEXT-UTF8-TRIM]", TEXTUTF8TRIM),
		)
	}
	return subject(s, ns)
}

var subtag abnf.Operator

// Subtag rule: subtag = 1*8ALPHA
func Subtag(s []byte, ns abnf.Nodes) abnf.Nodes {
	if subtag == nil {
		subtag = abnf.Repeat("subtag", uint(0x1), uint(0x8), abnf_core.ALPHA)
	}
	return subtag(s, ns)
}

var success abnf.Operator

// Success rule: Success = "200"
func Success(s []byte, ns abnf.Nodes) abnf.Nodes {
	if success == nil {
		success = abnf.Literal("Success", []byte{50, 48, 48})
	}
	return success(s, ns)
}

var supported abnf.Operator

// Supported rule: Supported = ( "Supported" / "k" ) HCOLON [option-tag *(COMMA option-tag)]
func Supported(s []byte, ns abnf.Nodes) abnf.Nodes {
	if supported == nil {
		supported = abnf.Concat(
			"Supported",
			abnf.Alt(
				"\"Supported\" / \"k\"",
				abnf.Literal("\"Supported\"", []byte{83, 117, 112, 112, 111, 114, 116, 101, 100}),
				abnf.Literal("\"k\"", []byte{107}),
			),
			HCOLON,
			abnf.Optional("[option-tag *(COMMA option-tag)]", abnf.Concat(
				"option-tag *(COMMA option-tag)",
				OptionTag,
				abnf.Repeat0Inf("*(COMMA option-tag)", abnf.Concat(
					"COMMA option-tag",
					COMMA,
					OptionTag,
				)),
			)),
		)
	}
	return supported(s, ns)
}

var textUTF8TRIM abnf.Operator

// TEXTUTF8TRIM rule: TEXT-UTF8-TRIM = 1*TEXT-UTF8char *(*LWS TEXT-UTF8char)
func TEXTUTF8TRIM(s []byte, ns abnf.Nodes) abnf.Nodes {
	if textUTF8TRIM == nil {
		textUTF8TRIM = abnf.Concat(
			"TEXT-UTF8-TRIM",
			abnf.Repeat1Inf("1*TEXT-UTF8char", TEXTUTF8char),
			abnf.Repeat0Inf("*(*LWS TEXT-UTF8char)", abnf.Concat(
				"*LWS TEXT-UTF8char",
				abnf.Repeat0Inf("*LWS", LWS),
				TEXTUTF8char,
			)),
		)
	}
	return textUTF8TRIM(s, ns)
}

var textUTF8char abnf.Operator

// TEXTUTF8char rule: TEXT-UTF8char = %x21-7E / UTF8-NONASCII
func TEXTUTF8char(s []byte, ns abnf.Nodes) abnf.Nodes {
	if textUTF8char == nil {
		textUTF8char = abnf.Alt(
			"TEXT-UTF8char",
			abnf.Range("%x21-7E", []byte{33}, []byte{126}),
			UTF8NONASCII,
		)
	}
	return textUTF8char(s, ns)
}

var tagParam abnf.Operator

// TagParam rule: tag-param = "tag" EQUAL token
func TagParam(s []byte, ns abnf.Nodes) abnf.Nodes {
	if tagParam == nil {
		tagParam = abnf.Concat(
			"tag-param",
			abnf.Literal("\"tag\"", []byte{116, 97, 103}),
			EQUAL,
			Token,
		)
	}
	return tagParam(s, ns)
}

var time abnf.Operator

// Time rule: time = 2DIGIT ":" 2DIGIT ":" 2DIGIT
func Time(s []byte, ns abnf.Nodes) abnf.Nodes {
	if time == nil {
		time = abnf.Concat(
			"time",
			abnf.RepeatN("2DIGIT", uint(0x2), abnf_core.DIGIT),
			abnf.Literal("\":\"", []byte{58}),
			abnf.RepeatN("2DIGIT", uint(0x2), abnf_core.DIGIT),
			abnf.Literal("\":\"", []byte{58}),
			abnf.RepeatN("2DIGIT", uint(0x2), abnf_core.DIGIT),
		)
	}
	return time(s, ns)
}

var timestamp abnf.Operator

// Timestamp rule: Timestamp = "Timestamp" HCOLON 1*(DIGIT) [ "." *(DIGIT) ] [ LWS delay ]
func Timestamp(s []byte, ns abnf.Nodes) abnf.Nodes {
	if timestamp == nil {
		timestamp = abnf.Concat(
			"Timestamp",
			abnf.Literal("\"Timestamp\"", []byte{84, 105, 109, 101, 115, 116, 97, 109, 112}),
			HCOLON,
			abnf.Repeat1Inf("1*(DIGIT)", abnf_core.DIGIT),
			abnf.Optional("[ \".\" *(DIGIT) ]", abnf.Concat(
				"\".\" *(DIGIT)",
				abnf.Literal("\".\"", []byte{46}),
				abnf.Repeat0Inf("*(DIGIT)", abnf_core.DIGIT),
			)),
			abnf.Optional("[ LWS delay ]", abnf.Concat(
				"LWS delay",
				LWS,
				Delay,
			)),
		)
	}
	return timestamp(s, ns)
}

var to abnf.Operator

// To rule: To = ( "To" / "t" ) HCOLON ( name-addr / addr-spec ) *( SEMI to-param )
func To(s []byte, ns abnf.Nodes) abnf.Nodes {
	if to == nil {
		to = abnf.Concat(
			"To",
			abnf.Alt(
				"\"To\" / \"t\"",
				abnf.Literal("\"To\"", []byte{84, 111}),
				abnf.Literal("\"t\"", []byte{116}),
			),
			HCOLON,
			abnf.Alt(
				"name-addr / addr-spec",
				NameAddr,
				AddrSpec,
			),
			abnf.Repeat0Inf("*( SEMI to-param )", abnf.Concat(
				"SEMI to-param",
				SEMI,
				ToParam,
			)),
		)
	}
	return to(s, ns)
}

var toParam abnf.Operator

// ToParam rule: to-param = tag-param / generic-param
func ToParam(s []byte, ns abnf.Nodes) abnf.Nodes {
	if toParam == nil {
		toParam = abnf.Alt(
			"to-param",
			TagParam,
			GenericParam,
		)
	}
	return toParam(s, ns)
}

var token abnf.Operator

// Token rule: token = 1*(alphanum / "-" / "." / "!" / "%" / "*" / "_" / "+" / "`" / "'" / "~" )
func Token(s []byte, ns abnf.Nodes) abnf.Nodes {
	if token == nil {
		token = abnf.Repeat1Inf("token", abnf.Alt(
			"alphanum / \"-\" / \".\" / \"!\" / \"%\" / \"*\" / \"_\" / \"+\" / \"`\" / \"'\" / \"~\"",
			Alphanum,
			abnf.Literal("\"-\"", []byte{45}),
			abnf.Literal("\".\"", []byte{46}),
			abnf.Literal("\"!\"", []byte{33}),
			abnf.Literal("\"%\"", []byte{37}),
			abnf.Literal("\"*\"", []byte{42}),
			abnf.Literal("\"_\"", []byte{95}),
			abnf.Literal("\"+\"", []byte{43}),
			abnf.Literal("\"`\"", []byte{96}),
			abnf.Literal("\"'\"", []byte{39}),
			abnf.Literal("\"~\"", []byte{126}),
		))
	}
	return token(s, ns)
}

var toplabel abnf.Operator

// Toplabel rule: toplabel = ALPHA / ALPHA *( alphanum / "-" ) alphanum
func Toplabel(s []byte, ns abnf.Nodes) abnf.Nodes {
	if toplabel == nil {
		toplabel = abnf.Alt(
			"toplabel",
			abnf_core.ALPHA,
			abnf.Concat(
				"ALPHA *( alphanum / \"-\" ) alphanum",
				abnf_core.ALPHA,
				abnf.Repeat0Inf("*( alphanum / \"-\" )", abnf.Alt(
					"alphanum / \"-\"",
					Alphanum,
					abnf.Literal("\"-\"", []byte{45}),
				)),
				Alphanum,
			),
		)
	}
	return toplabel(s, ns)
}

var transport abnf.Operator

// Transport rule: transport = "UDP" / "TCP" / "TLS" / "SCTP" / other-transport
func Transport(s []byte, ns abnf.Nodes) abnf.Nodes {
	if transport == nil {
		transport = abnf.Alt(
			"transport",
			abnf.Literal("\"UDP\"", []byte{85, 68, 80}),
			abnf.Literal("\"TCP\"", []byte{84, 67, 80}),
			abnf.Literal("\"TLS\"", []byte{84, 76, 83}),
			abnf.Literal("\"SCTP\"", []byte{83, 67, 84, 80}),
			OtherTransport,
		)
	}
	return transport(s, ns)
}

var transportParam abnf.Operator

// TransportParam rule: transport-param = "transport=" ( "udp" / "tcp" / "sctp" / "tls" / other-transport)
func TransportParam(s []byte, ns abnf.Nodes) abnf.Nodes {
	if transportParam == nil {
		transportParam = abnf.Concat(
			"transport-param",
			abnf.Literal("\"transport=\"", []byte{116, 114, 97, 110, 115, 112, 111, 114, 116, 61}),
			abnf.Alt(
				"\"udp\" / \"tcp\" / \"sctp\" / \"tls\" / other-transport",
				abnf.Literal("\"udp\"", []byte{117, 100, 112}),
				abnf.Literal("\"tcp\"", []byte{116, 99, 112}),
				abnf.Literal("\"sctp\"", []byte{115, 99, 116, 112}),
				abnf.Literal("\"tls\"", []byte{116, 108, 115}),
				OtherTransport,
			),
		)
	}
	return transportParam(s, ns)
}

var ttl abnf.Operator

// Ttl rule: ttl = 1*3DIGIT
func Ttl(s []byte, ns abnf.Nodes) abnf.Nodes {
	if ttl == nil {
		ttl = abnf.Repeat("ttl", uint(0x1), uint(0x3), abnf_core.DIGIT)
	}
	return ttl(s, ns)
}

var ttlParam abnf.Operator

// TtlParam rule: ttl-param = "ttl=" ttl
func TtlParam(s []byte, ns abnf.Nodes) abnf.Nodes {
	if ttlParam == nil {
		ttlParam = abnf.Concat(
			"ttl-param",
			abnf.Literal("\"ttl=\"", []byte{116, 116, 108, 61}),
			Ttl,
		)
	}
	return ttlParam(s, ns)
}

var uri abnf.Operator

// URI rule: URI = absoluteURI / abs-path
func URI(s []byte, ns abnf.Nodes) abnf.Nodes {
	if uri == nil {
		uri = abnf.Alt(
			"URI",
			AbsoluteURI,
			AbsPath,
		)
	}
	return uri(s, ns)
}

var utf8CONT abnf.Operator

// UTF8CONT rule: UTF8-CONT = %x80-BF
func UTF8CONT(s []byte, ns abnf.Nodes) abnf.Nodes {
	if utf8CONT == nil {
		utf8CONT = abnf.Range("UTF8-CONT", []byte{128}, []byte{191})
	}
	return utf8CONT(s, ns)
}

var utf8NONASCII abnf.Operator

// UTF8NONASCII rule: UTF8-NONASCII = %xC0-DF 1UTF8-CONT / %xE0-EF 2UTF8-CONT / %xF0-F7 3UTF8-CONT / %xF8-Fb 4UTF8-CONT / %xFC-FD 5UTF8-CONT
func UTF8NONASCII(s []byte, ns abnf.Nodes) abnf.Nodes {
	if utf8NONASCII == nil {
		utf8NONASCII = abnf.Alt(
			"UTF8-NONASCII",
			abnf.Concat(
				"%xC0-DF 1UTF8-CONT",
				abnf.Range("%xC0-DF", []byte{192}, []byte{223}),
				abnf.RepeatN("1UTF8-CONT", uint(0x1), UTF8CONT),
			),
			abnf.Concat(
				"%xE0-EF 2UTF8-CONT",
				abnf.Range("%xE0-EF", []byte{224}, []byte{239}),
				abnf.RepeatN("2UTF8-CONT", uint(0x2), UTF8CONT),
			),
			abnf.Concat(
				"%xF0-F7 3UTF8-CONT",
				abnf.Range("%xF0-F7", []byte{240}, []byte{247}),
				abnf.RepeatN("3UTF8-CONT", uint(0x3), UTF8CONT),
			),
			abnf.Concat(
				"%xF8-Fb 4UTF8-CONT",
				abnf.Range("%xF8-Fb", []byte{248}, []byte{251}),
				abnf.RepeatN("4UTF8-CONT", uint(0x4), UTF8CONT),
			),
			abnf.Concat(
				"%xFC-FD 5UTF8-CONT",
				abnf.Range("%xFC-FD", []byte{252}, []byte{253}),
				abnf.RepeatN("5UTF8-CONT", uint(0x5), UTF8CONT),
			),
		)
	}
	return utf8NONASCII(s, ns)
}

var unreserved abnf.Operator

// Unreserved rule: unreserved = alphanum / mark
func Unreserved(s []byte, ns abnf.Nodes) abnf.Nodes {
	if unreserved == nil {
		unreserved = abnf.Alt(
			"unreserved",
			Alphanum,
			Mark,
		)
	}
	return unreserved(s, ns)
}

var unsupported abnf.Operator

// Unsupported rule: Unsupported = "Unsupported" HCOLON option-tag *(COMMA option-tag)
func Unsupported(s []byte, ns abnf.Nodes) abnf.Nodes {
	if unsupported == nil {
		unsupported = abnf.Concat(
			"Unsupported",
			abnf.Literal("\"Unsupported\"", []byte{85, 110, 115, 117, 112, 112, 111, 114, 116, 101, 100}),
			HCOLON,
			OptionTag,
			abnf.Repeat0Inf("*(COMMA option-tag)", abnf.Concat(
				"COMMA option-tag",
				COMMA,
				OptionTag,
			)),
		)
	}
	return unsupported(s, ns)
}

var uriParameter abnf.Operator

// UriParameter rule: uri-parameter = transport-param / user-param / method-param / ttl-param / maddr-param / lr-param / other-param
func UriParameter(s []byte, ns abnf.Nodes) abnf.Nodes {
	if uriParameter == nil {
		uriParameter = abnf.Alt(
			"uri-parameter",
			TransportParam,
			UserParam,
			MethodParam,
			TtlParam,
			MaddrParam,
			LrParam,
			OtherParam,
		)
	}
	return uriParameter(s, ns)
}

var uriParameters abnf.Operator

// UriParameters rule: uri-parameters = *( ";" uri-parameter)
func UriParameters(s []byte, ns abnf.Nodes) abnf.Nodes {
	if uriParameters == nil {
		uriParameters = abnf.Repeat0Inf("uri-parameters", abnf.Concat(
			"\";\" uri-parameter",
			abnf.Literal("\";\"", []byte{59}),
			UriParameter,
		))
	}
	return uriParameters(s, ns)
}

var uric abnf.Operator

// Uric rule: uric = reserved / unreserved / escaped
func Uric(s []byte, ns abnf.Nodes) abnf.Nodes {
	if uric == nil {
		uric = abnf.Alt(
			"uric",
			Reserved,
			Unreserved,
			Escaped,
		)
	}
	return uric(s, ns)
}

var uricNoSlash abnf.Operator

// UricNoSlash rule: uric-no-slash = unreserved / escaped / ";" / "?" / ":" / "@" / "&" / "=" / "+" / "$" / ","
func UricNoSlash(s []byte, ns abnf.Nodes) abnf.Nodes {
	if uricNoSlash == nil {
		uricNoSlash = abnf.Alt(
			"uric-no-slash",
			Unreserved,
			Escaped,
			abnf.Literal("\";\"", []byte{59}),
			abnf.Literal("\"?\"", []byte{63}),
			abnf.Literal("\":\"", []byte{58}),
			abnf.Literal("\"@\"", []byte{64}),
			abnf.Literal("\"&\"", []byte{38}),
			abnf.Literal("\"=\"", []byte{61}),
			abnf.Literal("\"+\"", []byte{43}),
			abnf.Literal("\"$\"", []byte{36}),
			abnf.Literal("\",\"", []byte{44}),
		)
	}
	return uricNoSlash(s, ns)
}

var user abnf.Operator

// User rule: user = 1*( unreserved / escaped / user-unreserved )
func User(s []byte, ns abnf.Nodes) abnf.Nodes {
	if user == nil {
		user = abnf.Repeat1Inf("user", abnf.Alt(
			"unreserved / escaped / user-unreserved",
			Unreserved,
			Escaped,
			UserUnreserved,
		))
	}
	return user(s, ns)
}

var userAgent abnf.Operator

// UserAgent rule: User-Agent = "User-Agent" HCOLON server-val *(LWS server-val)
func UserAgent(s []byte, ns abnf.Nodes) abnf.Nodes {
	if userAgent == nil {
		userAgent = abnf.Concat(
			"User-Agent",
			abnf.Literal("\"User-Agent\"", []byte{85, 115, 101, 114, 45, 65, 103, 101, 110, 116}),
			HCOLON,
			ServerVal,
			abnf.Repeat0Inf("*(LWS server-val)", abnf.Concat(
				"LWS server-val",
				LWS,
				ServerVal,
			)),
		)
	}
	return userAgent(s, ns)
}

var userParam abnf.Operator

// UserParam rule: user-param = "user=" ( "phone" / "ip" / other-user)
func UserParam(s []byte, ns abnf.Nodes) abnf.Nodes {
	if userParam == nil {
		userParam = abnf.Concat(
			"user-param",
			abnf.Literal("\"user=\"", []byte{117, 115, 101, 114, 61}),
			abnf.Alt(
				"\"phone\" / \"ip\" / other-user",
				abnf.Literal("\"phone\"", []byte{112, 104, 111, 110, 101}),
				abnf.Literal("\"ip\"", []byte{105, 112}),
				OtherUser,
			),
		)
	}
	return userParam(s, ns)
}

var userUnreserved abnf.Operator

// UserUnreserved rule: user-unreserved = "&" / "=" / "+" / "$" / "," / ";" / "?" / "/"
func UserUnreserved(s []byte, ns abnf.Nodes) abnf.Nodes {
	if userUnreserved == nil {
		userUnreserved = abnf.Alt(
			"user-unreserved",
			abnf.Literal("\"&\"", []byte{38}),
			abnf.Literal("\"=\"", []byte{61}),
			abnf.Literal("\"+\"", []byte{43}),
			abnf.Literal("\"$\"", []byte{36}),
			abnf.Literal("\",\"", []byte{44}),
			abnf.Literal("\";\"", []byte{59}),
			abnf.Literal("\"?\"", []byte{63}),
			abnf.Literal("\"/\"", []byte{47}),
		)
	}
	return userUnreserved(s, ns)
}

var userinfo abnf.Operator

// Userinfo rule: userinfo = user [ ":" password ] "@"
func Userinfo(s []byte, ns abnf.Nodes) abnf.Nodes {
	if userinfo == nil {
		userinfo = abnf.Concat(
			"userinfo",
			User,
			abnf.Optional("[ \":\" password ]", abnf.Concat(
				"\":\" password",
				abnf.Literal("\":\"", []byte{58}),
				Password,
			)),
			abnf.Literal("\"@\"", []byte{64}),
		)
	}
	return userinfo(s, ns)
}

var username abnf.Operator

// Username rule: username = "username" EQUAL username-value
func Username(s []byte, ns abnf.Nodes) abnf.Nodes {
	if username == nil {
		username = abnf.Concat(
			"username",
			abnf.Literal("\"username\"", []byte{117, 115, 101, 114, 110, 97, 109, 101}),
			EQUAL,
			UsernameValue,
		)
	}
	return username(s, ns)
}

var usernameValue abnf.Operator

// UsernameValue rule: username-value = quoted-string
func UsernameValue(s []byte, ns abnf.Nodes) abnf.Nodes {
	if usernameValue == nil {
		usernameValue = QuotedString
	}
	return usernameValue(s, ns)
}

var vschar abnf.Operator

// VSCHAR rule: VSCHAR = %x20-7E
func VSCHAR(s []byte, ns abnf.Nodes) abnf.Nodes {
	if vschar == nil {
		vschar = abnf.Range("VSCHAR", []byte{32}, []byte{126})
	}
	return vschar(s, ns)
}

var via abnf.Operator

// Via rule: Via = ( "Via" / "v" ) HCOLON via-parm *(COMMA via-parm)
func Via(s []byte, ns abnf.Nodes) abnf.Nodes {
	if via == nil {
		via = abnf.Concat(
			"Via",
			abnf.Alt(
				"\"Via\" / \"v\"",
				abnf.Literal("\"Via\"", []byte{86, 105, 97}),
				abnf.Literal("\"v\"", []byte{118}),
			),
			HCOLON,
			ViaParm,
			abnf.Repeat0Inf("*(COMMA via-parm)", abnf.Concat(
				"COMMA via-parm",
				COMMA,
				ViaParm,
			)),
		)
	}
	return via(s, ns)
}

var viaBranch abnf.Operator

// ViaBranch rule: via-branch = "branch" EQUAL token
func ViaBranch(s []byte, ns abnf.Nodes) abnf.Nodes {
	if viaBranch == nil {
		viaBranch = abnf.Concat(
			"via-branch",
			abnf.Literal("\"branch\"", []byte{98, 114, 97, 110, 99, 104}),
			EQUAL,
			Token,
		)
	}
	return viaBranch(s, ns)
}

var viaExtension abnf.Operator

// ViaExtension rule: via-extension = generic-param
func ViaExtension(s []byte, ns abnf.Nodes) abnf.Nodes {
	if viaExtension == nil {
		viaExtension = GenericParam
	}
	return viaExtension(s, ns)
}

var viaMaddr abnf.Operator

// ViaMaddr rule: via-maddr = "maddr" EQUAL host
func ViaMaddr(s []byte, ns abnf.Nodes) abnf.Nodes {
	if viaMaddr == nil {
		viaMaddr = abnf.Concat(
			"via-maddr",
			abnf.Literal("\"maddr\"", []byte{109, 97, 100, 100, 114}),
			EQUAL,
			Host,
		)
	}
	return viaMaddr(s, ns)
}

var viaParams abnf.Operator

// ViaParams rule: via-params = via-ttl / via-maddr / via-received / via-branch / response-port / via-extension
func ViaParams(s []byte, ns abnf.Nodes) abnf.Nodes {
	if viaParams == nil {
		viaParams = abnf.Alt(
			"via-params",
			ViaTtl,
			ViaMaddr,
			ViaReceived,
			ViaBranch,
			ResponsePort,
			ViaExtension,
		)
	}
	return viaParams(s, ns)
}

var viaParm abnf.Operator

// ViaParm rule: via-parm = sent-protocol LWS sent-by *( SEMI via-params )
func ViaParm(s []byte, ns abnf.Nodes) abnf.Nodes {
	if viaParm == nil {
		viaParm = abnf.Concat(
			"via-parm",
			SentProtocol,
			LWS,
			SentBy,
			abnf.Repeat0Inf("*( SEMI via-params )", abnf.Concat(
				"SEMI via-params",
				SEMI,
				ViaParams,
			)),
		)
	}
	return viaParm(s, ns)
}

var viaReceived abnf.Operator

// ViaReceived rule: via-received = "received" EQUAL (IPv4address / IPv6address)
func ViaReceived(s []byte, ns abnf.Nodes) abnf.Nodes {
	if viaReceived == nil {
		viaReceived = abnf.Concat(
			"via-received",
			abnf.Literal("\"received\"", []byte{114, 101, 99, 101, 105, 118, 101, 100}),
			EQUAL,
			abnf.Alt(
				"IPv4address / IPv6address",
				IPv4address,
				IPv6address,
			),
		)
	}
	return viaReceived(s, ns)
}

var viaTtl abnf.Operator

// ViaTtl rule: via-ttl = "ttl" EQUAL ttl
func ViaTtl(s []byte, ns abnf.Nodes) abnf.Nodes {
	if viaTtl == nil {
		viaTtl = abnf.Concat(
			"via-ttl",
			abnf.Literal("\"ttl\"", []byte{116, 116, 108}),
			EQUAL,
			Ttl,
		)
	}
	return viaTtl(s, ns)
}

var wwwAuthenticate abnf.Operator

// WWWAuthenticate rule: WWW-Authenticate = "WWW-Authenticate" HCOLON challenge
func WWWAuthenticate(s []byte, ns abnf.Nodes) abnf.Nodes {
	if wwwAuthenticate == nil {
		wwwAuthenticate = abnf.Concat(
			"WWW-Authenticate",
			abnf.Literal("\"WWW-Authenticate\"", []byte{87, 87, 87, 45, 65, 117, 116, 104, 101, 110, 116, 105, 99, 97, 116, 101}),
			HCOLON,
			Challenge,
		)
	}
	return wwwAuthenticate(s, ns)
}

var warnAgent abnf.Operator

// WarnAgent rule: warn-agent = hostport / pseudonym
func WarnAgent(s []byte, ns abnf.Nodes) abnf.Nodes {
	if warnAgent == nil {
		warnAgent = abnf.Alt(
			"warn-agent",
			Hostport,
			Pseudonym,
		)
	}
	return warnAgent(s, ns)
}

var warnCode abnf.Operator

// WarnCode rule: warn-code = 3DIGIT
func WarnCode(s []byte, ns abnf.Nodes) abnf.Nodes {
	if warnCode == nil {
		warnCode = abnf.RepeatN("warn-code", uint(0x3), abnf_core.DIGIT)
	}
	return warnCode(s, ns)
}

var warnText abnf.Operator

// WarnText rule: warn-text = quoted-string
func WarnText(s []byte, ns abnf.Nodes) abnf.Nodes {
	if warnText == nil {
		warnText = QuotedString
	}
	return warnText(s, ns)
}

var warning abnf.Operator

// Warning rule: Warning = "Warning" HCOLON warning-value *(COMMA warning-value)
func Warning(s []byte, ns abnf.Nodes) abnf.Nodes {
	if warning == nil {
		warning = abnf.Concat(
			"Warning",
			abnf.Literal("\"Warning\"", []byte{87, 97, 114, 110, 105, 110, 103}),
			HCOLON,
			WarningValue,
			abnf.Repeat0Inf("*(COMMA warning-value)", abnf.Concat(
				"COMMA warning-value",
				COMMA,
				WarningValue,
			)),
		)
	}
	return warning(s, ns)
}

var warningValue abnf.Operator

// WarningValue rule: warning-value = warn-code SP warn-agent SP warn-text
func WarningValue(s []byte, ns abnf.Nodes) abnf.Nodes {
	if warningValue == nil {
		warningValue = abnf.Concat(
			"warning-value",
			WarnCode,
			abnf_core.SP,
			WarnAgent,
			abnf_core.SP,
			WarnText,
		)
	}
	return warningValue(s, ns)
}

var wkday abnf.Operator

// Wkday rule: wkday = "Mon" / "Tue" / "Wed" / "Thu" / "Fri" / "Sat" / "Sun"
func Wkday(s []byte, ns abnf.Nodes) abnf.Nodes {
	if wkday == nil {
		wkday = abnf.Alt(
			"wkday",
			abnf.Literal("\"Mon\"", []byte{77, 111, 110}),
			abnf.Literal("\"Tue\"", []byte{84, 117, 101}),
			abnf.Literal("\"Wed\"", []byte{87, 101, 100}),
			abnf.Literal("\"Thu\"", []byte{84, 104, 117}),
			abnf.Literal("\"Fri\"", []byte{70, 114, 105}),
			abnf.Literal("\"Sat\"", []byte{83, 97, 116}),
			abnf.Literal("\"Sun\"", []byte{83, 117, 110}),
		)
	}
	return wkday(s, ns)
}

var word abnf.Operator

// Word rule: word = 1*(alphanum / "-" / "." / "!" / "%" / "*" / "_" / "+" / "`" / "'" / "~" / "(" / ")" / "<" / ">" / ":" / "\" / DQUOTE / "/" / "[" / "]" / "?" / "{" / "}" )
func Word(s []byte, ns abnf.Nodes) abnf.Nodes {
	if word == nil {
		word = abnf.Repeat1Inf("word", abnf.Alt(
			"alphanum / \"-\" / \".\" / \"!\" / \"%\" / \"*\" / \"_\" / \"+\" / \"`\" / \"'\" / \"~\" / \"(\" / \")\" / \"<\" / \">\" / \":\" / \"\\\" / DQUOTE / \"/\" / \"[\" / \"]\" / \"?\" / \"{\" / \"}\"",
			Alphanum,
			abnf.Literal("\"-\"", []byte{45}),
			abnf.Literal("\".\"", []byte{46}),
			abnf.Literal("\"!\"", []byte{33}),
			abnf.Literal("\"%\"", []byte{37}),
			abnf.Literal("\"*\"", []byte{42}),
			abnf.Literal("\"_\"", []byte{95}),
			abnf.Literal("\"+\"", []byte{43}),
			abnf.Literal("\"`\"", []byte{96}),
			abnf.Literal("\"'\"", []byte{39}),
			abnf.Literal("\"~\"", []byte{126}),
			abnf.Literal("\"(\"", []byte{40}),
			abnf.Literal("\")\"", []byte{41}),
			abnf.Literal("\"<\"", []byte{60}),
			abnf.Literal("\">\"", []byte{62}),
			abnf.Literal("\":\"", []byte{58}),
			abnf.Literal("\"\\\\\"", []byte{92}),
			abnf_core.DQUOTE,
			abnf.Literal("\"/\"", []byte{47}),
			abnf.Literal("\"[\"", []byte{91}),
			abnf.Literal("\"]\"", []byte{93}),
			abnf.Literal("\"?\"", []byte{63}),
			abnf.Literal("\"{\"", []byte{123}),
			abnf.Literal("\"}\"", []byte{125}),
		))
	}
	return word(s, ns)
}

var xToken abnf.Operator

// XToken rule: x-token = "x-" token
func XToken(s []byte, ns abnf.Nodes) abnf.Nodes {
	if xToken == nil {
		xToken = abnf.Concat(
			"x-token",
			abnf.Literal("\"x-\"", []byte{120, 45}),
			Token,
		)
	}
	return xToken(s, ns)
}
